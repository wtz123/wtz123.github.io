<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Tony's blog]]></title>
  <subtitle><![CDATA[Talk is cheap, show me the code.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wangtianzhi.cn/"/>
  <updated>2016-04-16T02:26:33.000Z</updated>
  <id>http://wangtianzhi.cn/</id>
  
  <author>
    <name><![CDATA[Tony]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[AQS并发编程源码分析]]></title>
    <link href="http://wangtianzhi.cn/2016/04/12/AQS-of-concurrent/"/>
    <id>http://wangtianzhi.cn/2016/04/12/AQS-of-concurrent/</id>
    <published>2016-04-12T11:26:33.000Z</published>
    <updated>2016-04-16T02:26:33.000Z</updated>
    <content type="html"><![CDATA[<p>在JDK的concurrent包中，提供了丰富的并发处理工具，其中的很多同步器是基于AQS（AbstractQueuedSynchronizer）这个类来实现的，如ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch、FutureTask（JDK1.7开始不依赖AQS）等。在JDK1.8中，还有如下的类继承了AQS:</p>
<p><img src="/img/AQS-of-concurrent/AQS-subclass.png" width="300" height="200" alt="AQS子类" align="center"></p>
<h3 id="一-_Unsafe类">一. Unsafe类</h3><p>AQS底层调用了很多Unsafe类里的方法来进行并发的处理，Unsafe类里的方法基本都是native的，通过利用系统硬件的支持，来实现并发的控制。其中利用到硬件的最重要的一个指令是CAS(compare and swap)，CAS包含了3个操作数：需要读写的内存位置V、进行比较的值A和拟写入的新值B，当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。</p>
<p>在concurrent包的atomic目录下包含了很多原子变量类，如AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference等，这些原子变量类的底层都是利用unsafe类提供的方法来实现的。</p>
<h3 id="二-_AQS">二. AQS</h3><p>AQS是一个用于构造锁和同步器的框架，许多同步器都可通过AQS很容易且高效的构造出来。它解决了在实现同步器时涉及的大量细节问题。</p>
<p>AQS有一个整数状态信息，可以通过getState、setState以及compareAndSetState等方法来进行操作，这个整数可以用于表示任意的状态。例如ReentrantLock用它来表示所有者线程已经重复获取该锁的次数，Semaphore用它来表示剩余的许可数量，FutureTask（JDK1.7以前）用它来表示任务的状态（尚未开始、正在运行、已完成、已取消），ReentrantReadWriteLock用它的低16位来表示写操作的计数，高16位表示读操作的计数等等。此外，AQS的父类有一个exclusiveOwnerThread变量，可以用来存储独占锁情形下当前的执行线程。</p>
<p>在AQS中还维护着一个队列（采用双向链表实现），用来存储等待获取锁的线程，队列由Node类型的节点组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="keyword">volatile</span> Thread thread;       </span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure>
<p>waitStatus用来表示:</p>
<ul>
<li>CANCELLED </li>
<li>SIGNAL 只有SIGNAL状态的才能调用LockSupport.park将线程挂起，刚加入等待队列时都为0（Condition为CONDITION）</li>
<li>CONDITION </li>
<li>PROPAGATE</li>
</ul>
<p>AQS维护的队列<br><img src="/img/AQS-of-concurrent/aqs-node-link.png" alt="AQS队列"><br><strong>队列的第一个节点head就是代表持有锁的节点</strong>。</p>
<p>在使用AQS的同步器中，并不是直接继承AQS，而是将一些功能委托给AQS，在同步器类内部中定义内部类，通过内部类对象来调用AQS的功能。因为如果直接继承AQS，那么AQS中的很多在同步器中的无用的方法，也会暴露给调用者，调用者很容易勿用，破坏简洁性。</p>
<p>AQS的功能可以分为两类：独占功能和共享锁功能，下面用ReentrantLock源码来分析独占功能的在源码中的使用方法，以ReentrantReadWriteLock源码来分析共享锁功能的使用方法。</p>
<h3 id="三-_独占功能-ReentrantLock&amp;Condition">三. 独占功能-ReentrantLock&amp;Condition</h3><p>本文以ReentrantLock为例来分析独占锁的使用，ReentrantLock的类图如下所示：</p>
<p><img src="/img/AQS-of-concurrent/ReentrantLock.png" width="500" height="400" alt="ReentrantLock类图" align="center"></p>
<p>源码及核心逻辑解释写在了下面的源码注释中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FairSync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NonfairSync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="function"><span class="keyword">else</span></span><br><span class="line">        <span class="title">acquire</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获取锁，如果没获取到，放入等待队列中，同时调用acquireQueued尝试park，挂起线程</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();<span class="comment">//如果是因为被中断而unpark的，就使线程中断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FaireSync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前锁刚好空着，且队列前面没有在排队的，通过尝试更改state获取锁,获取锁后将exclusiveOwnerThread设为当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(current == getExclusiveOwnerThread()</span>) </span>&#123;<span class="comment">//可重入锁</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NonfairSync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//不公平锁，直接尝试更改state来获取锁，不查看是否有其它线程在队列等待获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(current == getExclusiveOwnerThread()</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS</span></span><br><span class="line"><span class="comment">//返回线程是否被中断</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//node的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果node的前驱节点为head（head为当前占有锁的节点），则下一个获取锁的节点就是node，尝试获取锁，获取到锁后更改head为node</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果node的前驱节点p的waitStatus为SIGNAL,表示p已被设置为:在release时，要通知后继节点(节点p对应的线程在执行release时，会unpark后继节点)，因此p的后继节点node可以安心的park了，因此在parkAndCheckInterrupt方法里调用了LockSupport.park来使线程不被调度（park后，只有在被其它线程unpark或interrupt等情况时才恢复执行）；unpark函数可以先于park调用。比如线程B调用unpark函数，给线程A发了一个“许可”，那么当线程A调用park时，它发现已经有“许可”了，那么它会马上再继续运行，所以在上面tryAcquire到下面代码park之间，不用担心因为其它线程释放了锁，而导致当前线程park后一直无法unpark的问题</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS</span></span><br><span class="line"><span class="comment">//如果node的前驱节点pred的waitStatus为SINGAL，表示pred在release会unparkpred的后继节点node，因此node可以安心park；如果waitStatus&gt;0表示已经被取消，将node的前驱节点指向前面最近的未被取消的节点；否则将前驱节点waitStatus设置为SIGNAL，调用者需要再尝试获取锁，获取不到再park</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">        * This node has already set status asking a release</span><br><span class="line">        * to signal it, so it can safely park.</span><br><span class="line">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">        * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">        * indicate retry.</span><br><span class="line">        */</span></span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">        * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">        * need a signal, but don't park yet.  Caller will need to</span><br><span class="line">        * retry to make sure it cannot acquire before parking.</span><br><span class="line">        */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">//tryRelease只更改status和持有锁的线程变量，不用更改head，在acquireQueued中会更改</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AQS</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">    * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">    * fails or if status is changed by waiting thread.</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    * Thread to unpark is held in successor, which is normally</span><br><span class="line">    * just the next node.  But if cancelled or apparently null,</span><br><span class="line">    * traverse backwards from tail to find the actual</span><br><span class="line">    * non-cancelled successor.</span><br><span class="line">    */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒队列的后续节点，如果是共享锁，后继节点会递归的唤醒自己的后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Condition</code>之于wait/notify，就像Lock之于synchronize，在执行wait/notify时需要先获取对象的控制权，比如将对象用synchronize放在同步块中，在同步块里面执行wait/notify，否则会报IllegalMonitorStateException异常；同样的，在执行Condition的await/signal之前，需要先调用ReentrantLock.lock()等方法获取锁，在锁里面执行await/signal。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();<span class="comment">//创建waitStatus=CONDITION的node，添加到Condition自己维护的链表中</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);<span class="comment">//释放锁；在执行await之前，都需要调用ReentrantLock的lock,await时需要释放持有的锁</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//释放完当前线程占有的锁后，便利AQS队列，看当前节点是否在队列中，如果不在，说明它还没有竞争锁的资格，继续park，直到它被加入到队列中。被加入到队列中是在其它线程调用signal的时候。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被其它线程调用signal唤醒后，重新开始竞争锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);<span class="comment">//唤醒Condition等待队列的第一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将老的头节点，加入到AQS等待队列中</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">    * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">    * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">    * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">    */</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四-_共享锁功能-ReentrantReadWriteLock&amp;Semaphore">四. 共享锁功能-ReentrantReadWriteLock&amp;Semaphore</h3><p>ReentrantReadWriteLock的ReadLock、Semaphore等都是利用AQS的共享方法来实现的,下文以ReentrantReadWriteLock来分析共享锁的使用方法，Semaphore的实现方式类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReadLock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Walkthrough:</span><br><span class="line">	 * 1. If write lock held by another thread, fail.</span><br><span class="line">	 * 2. Otherwise, this thread is eligible for</span><br><span class="line">	 *    lock wrt state, so ask if it should block</span><br><span class="line">	 *    because of queue policy. If not, try</span><br><span class="line">	 *    to grant by CASing state and updating count.</span><br><span class="line">	 *    Note that step does not check for reentrant</span><br><span class="line">	 *    acquires, which is postponed to full version</span><br><span class="line">	 *    to avoid having to check hold count in</span><br><span class="line">	 *    the more typical non-reentrant case.</span><br><span class="line">	 * 3. If step 2 fails either because thread</span><br><span class="line">	 *    apparently not eligible or CAS fails or count</span><br><span class="line">	 *    saturated, chain to version with full retry loop.</span><br><span class="line">	 */</span></span><br><span class="line">	Thread current = Thread.currentThread();</span><br><span class="line">	<span class="keyword">int</span> c = getState();</span><br><span class="line">	<span class="comment">//status的低16位表示写锁的计数，低16位不等于0表示现在有进程持有写锁，其他线程不能获取锁，不过同一个线程在持有写锁的情况下，如果等待队列的第一个节点（head的后继节点）不是等待写锁，那么可以获取读锁</span></span><br><span class="line">	<span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">		getExclusiveOwnerThread() != current)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">	<span class="comment">//公平锁在要获取读锁时，如果已经有线程在等待队列等待，则不能抢占；非公平锁在等待队列的第一个线程不是等待写锁的话，且当前没有线程占有写锁，则可以直接抢占读锁</span></span><br><span class="line">	<span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">		r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">		compareAndSetState(c, c + SHARED_UNIT)) &#123;<span class="comment">//读锁的计数用status的高16位表示</span></span><br><span class="line">		<span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">			firstReader = current;</span><br><span class="line">			firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(firstReader == current)</span> </span>&#123;</span><br><span class="line">			firstReaderHoldCount++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			HoldCounter rh = cachedHoldCounter;</span><br><span class="line">			<span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">				cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">			<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(rh.count == <span class="number">0</span>)</span></span><br><span class="line">				readHolds.<span class="title">set</span><span class="params">(rh)</span></span>;</span><br><span class="line">			rh.count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Walkthrough:</span><br><span class="line">	 * 1. If read count nonzero or write count nonzero</span><br><span class="line">	 *    and owner is a different thread, fail.</span><br><span class="line">	 * 2. If count would saturate, fail. (This can only</span><br><span class="line">	 *    happen if count is already nonzero.)</span><br><span class="line">	 * 3. Otherwise, this thread is eligible for lock if</span><br><span class="line">	 *    it is either a reentrant acquire or</span><br><span class="line">	 *    queue policy allows it. If so, update state</span><br><span class="line">	 *    and set owner.</span><br><span class="line">	 */</span></span><br><span class="line">	Thread current = Thread.currentThread();</span><br><span class="line">	<span class="keyword">int</span> c = getState();</span><br><span class="line">	<span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">	<span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">		<span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">		<span class="comment">// Reentrant acquire</span></span><br><span class="line">		setState(c + acquires);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">////获取写锁时，如果当前读写锁都没有被占有，公平锁会根据是否等待队列前面有等待的线程来判断能否获取写锁，非公平锁则直接获取写锁</span></span><br><span class="line">	<span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">		!compareAndSetState(c, c + acquires))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	setExclusiveOwnerThread(current);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取到锁后，修改head为当前的node，并将后继等待读锁的也唤醒，唤醒是递归的</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    * Try to signal next queued node if:</span><br><span class="line">    *   Propagation was indicated by caller,</span><br><span class="line">    *     or was recorded (as h.waitStatus either before</span><br><span class="line">    *     or after setHead) by a previous operation</span><br><span class="line">    *     (note: this uses sign-check of waitStatus because</span><br><span class="line">    *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">    * and</span><br><span class="line">    *   The next node is waiting in shared mode,</span><br><span class="line">    *     or we don't know, because it appears null</span><br><span class="line">    *</span><br><span class="line">    * The conservatism in both of these checks may cause</span><br><span class="line">    * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">    * racing acquires/releases, so most need signals now or soon</span><br><span class="line">    * anyway.</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> || (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">        doReleaseShared();<span class="comment">//如果后继节点是shared的，唤醒它</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    * Ensure that a release propagates, even if there are other</span><br><span class="line">    * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="line">    * way of trying to unparkSuccessor of head if it needs</span><br><span class="line">    * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="line">    * ensure that upon release, propagation continues.</span><br><span class="line">    * Additionally, we must loop in case a new node is added</span><br><span class="line">    * while we are doing this. Also, unlike other uses of</span><br><span class="line">    * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="line">    * fails, if so rechecking.</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)</span>)</span><br><span class="line">                <span class="keyword">continue</span></span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Semaphore</code>也是share模式，跟ReentrantReadWriteLock的读锁机制类似，只不过ReentrantReadWriteLock的ReadLock在lock()时status是递增的，而Semaphore调用acquire()方法是递减的，当减到0时就要在队列等待，直到其他线程调用了release()且status的值&gt;=等待线程要获取的permit的数量时，才获取permit。</p>
<p>在Semaphore中，公平与不公平的一个区别为：公平的，假如当前有线程A和B在等待，A的permit=4，B的permit=1，当前的status=2，线程A比线程B早到，则虽然status&gt;1，但是由于A排在B前面，因此B还是得等待；如果非公平的，则B可以直接获取permit；创建Semaphore对象时，如果没有指定是否公平的参数，则默认为不公平的。</p>
<h3 id="五-_参考文献">五. 参考文献</h3><ol>
<li>java并发编程实战</li>
<li><a href="http://www.liuinsect.com/2014/01/27/how_to_understand_condition/" target="_blank" rel="external">怎么理解Condition</a></li>
<li><a href="http://blog.csdn.net/hengyunabc/article/details/28126139" target="_blank" rel="external">Java的LockSupport.park()实现分析</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在JDK的concurrent包中，提供了丰富的并发处理工具，其中的很多同步器是基于AQS（AbstractQueuedSynchronizer）这个类来实现的，如ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDow]]>
    </summary>
    
      <category term="AQS" scheme="http://wangtianzhi.cn/tags/AQS/"/>
    
      <category term="JDK" scheme="http://wangtianzhi.cn/tags/JDK/"/>
    
      <category term="ReentrantLock" scheme="http://wangtianzhi.cn/tags/ReentrantLock/"/>
    
      <category term="并发" scheme="http://wangtianzhi.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://wangtianzhi.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[https原理总结]]></title>
    <link href="http://wangtianzhi.cn/2016/03/22/https-principle-analysis/"/>
    <id>http://wangtianzhi.cn/2016/03/22/https-principle-analysis/</id>
    <published>2016-03-22T12:20:40.000Z</published>
    <updated>2016-03-22T13:43:29.000Z</updated>
    <content type="html"><![CDATA[<p>最近项目中要用到https，找运维人员配置相关参数时，被问到要配置单向认证还是双向认证，瞬间傻了，已是回来研究了下https的原理。</p>
<p>https已经成为电商网站、银行、资金有关的系统的标配，特别是现在网络流量劫持增多、资金频繁被盗等场景下，重要网站https化势在必行。那么https原理是什么？单向认证、双向认证、为何要依赖于证书颁发机构、12306网站为何需要配置根证书？这些都是值得探讨的。</p>
<h3 id="一-https原理">一.https原理</h3><p>网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。SSL目前的版本是3.0，被IETF（Internet Engineering Task Force）定义在RFC 6101中，之后IETF对SSL 3.0进行了升级，于是出现了TLS（Transport Layer Security） 1.0，定义在RFC 2246。实际上我们现在的HTTPS都是用的TLS协议，但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持。</p>
<p><img src="/img/https-principle-analysis/https-handle-process.png" alt="https原理图-图片来自网络"></p>
<p><strong>1. 客户端发起https请求</strong></p>
<p>这个过程中客户端发送的信息会说明它支持的最高TLS协议版本、随机数、密码算法列表及压缩方法给服务端；</p>
<p><strong>2. 服务端配置</strong></p>
<p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。</p>
<p><strong>3. 服务器返回证书</strong></p>
<p>发送给浏览器的证书包含公钥、证书的颁发机构、过期时间、域、签名等信息；</p>
<p><strong>4. 验证证书</strong></p>
<p>这部分工作是由客户端的TLS来完成的，客户端会验证证书是否有效，如服务器证书是否过期、发行服务器证书的CA是否可靠、发行CA的公钥能否正确解开服务器证书的发行CA的数字签名、服务器证书上的域名是否和服务器的实际域名相匹配等等，如果发现异常则会弹出一个警告框，提示证书存在问题，让用户选择是否继续。</p>
<p>证书中会包含数字签名，该数字签名是加密过的，是用<strong>颁发机构的私钥</strong>对本证书的公钥、名称及其他信息做hash散列加密而生成的。客户端浏览器会一层层的去寻找颁发者的证书，直到自签名的<strong>根证书</strong>，然后通过相应的公钥再反过来验证下一级的数字签名的正确性，如果不能正常解密，则就是”发现异常”，说明该证书是伪造的。</p>
<p><strong>5. 传送加密信息</strong></p>
<p>如果上步证书验证通过，则生成一个<strong>随机值A</strong>作为后面通讯的密钥（对称加密），用证书的公钥对这个随机值加密，发送该加密后的随机值到服务器端，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>
<p>如果服务器要求客户端的身份认证（在握手过程中为可选）即<strong>双向认证</strong>，客户端可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户端自己的证书以及加密过的随机值A发送给服务器。</p>
<p><strong>6. 服务端解密信息</strong></p>
<p>服务端用证书的私钥解密后，得到了客户端传过来的随机值A，至此一个非对称加密的过程结束，看到TLS利用非对称加密实现了身份认证和密钥协商。</p>
<p>如果服务器要求客户端的身份认证（双向认证），服务器必须检验客户端证书和签名随机数的合法性，具体的合法性验证包括：客户端证书是否过期，发行客户端证书的CA是否可靠，发行CA的公钥能否正确解开客户端证书的发行CA的数字签名，检查客户端证书是否在证书废止列表（CRL）中。如果合法性验证没有通过，通讯立刻中断；如果合法性验证通过，才获取随机值A,进行后续的步骤。</p>
<p><strong>7. 传输加密后的信息</strong></p>
<p>用上文客户端传来的密钥A加密客户端请求的内容，发给客户端。</p>
<p><strong>8. 客户端解密信息</strong></p>
<p>客户端用密钥A解密消息，获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。（为什么不直接使用公钥和私钥进行通讯？因为非对称解密相当损耗CPU性能，https网站cpu损耗差不多90%的性能损耗都在非对称秘钥的解密上。全部内容都用非对称加密交流性能大大下降）</p>
<p><strong>不管是双向认证还是单向认证，服务端都需要配置CA证书，单向认证不需要客户端拥有CA证书，双向认证客户端需要拥有CA证书。</strong></p>
<p>一般Web应用都是采用单向认证的，原因很简单，用户数目广泛，且无需做在通讯层做用户身份验证，一般都在应用逻辑层来保证用户的合法登入。但如果是企业应用对接，情况就不一样，可能会要求对客户端（相对而言）做身份验证。这时就需要做双向认证。</p>
<h3 id="二-证书颁发机构">二.证书颁发机构</h3><p>如果任何的证书客户端都信任，那么在上面的步骤1中，攻击者可以通过DNS劫持或IP伪造的方法使其访问到攻击者的服务器上，攻击者伪造一个同样域名的证书发给客户端，客户端验证了日期、域等都没错，从而骗过了客户端。</p>
<p>为了抵御这种中间人攻击，证书需要由可信的证书颁发机构颁发，形成一个证书链（比如Gmail的证书链为：最底层为网域mail.google.com，上一层为Thawte SGC CA证书颁发机构，最顶层为很有名的VeriSign证书颁发机构）。那么，浏览器除了需要验证域和有效期外，还要检查证书链中的上级证书公钥是否有效，上级的上级证书公钥是否有效，直至根证书公钥为止。这样就可以有效避免中间人攻击了，因为<strong>根证书公钥都是预装在浏览器或操作系统</strong>中的，黑客如果不是暴力破解，无法得到根证书的私钥，如果黑客自己生成一个私钥，浏览器验证根证书公钥的时候发现无法通过浏览器中预装的公钥加密数据后使用这个私钥进行解密，从而判定这个公钥是无效的。这个方案也是现在https通讯通常的方案。</p>
<p>那么，这个现在所有的浏览器正在使用的https通讯方案就无懈可击了吗？答案仍是否定的。我们可以看到，在后一个方案中，https的安全性需要在证书颁发机构公信力的强有力保障前提下才能发挥作用。如果证书颁发机构在没有验证黑客为mail.google.com的持有者的情况下，给黑客颁发了网域为mail.google.com的证书，那么黑客的中间人攻击又可以顺利实施。</p>
<p>12306网站就是没有采用证书颁发机构颁发的证书，而是自己制作证书，因此需要在浏览器安装根证书，否则访问的时候就会提示‘此网站的安全证书有问题’，阻止用户继续访问。</p>
<p>证书分为DV(Digital Verification)，OV(Organization Verification)和EV(Extended Verification)，其中EV证书最贵，可以在浏览器中看到绿色的就是EV证书。</p>
<h3 id="三-参考文献">三.参考文献</h3><ol>
<li><a href="http://blog.csdn.net/sean_cd/article/details/6966130" target="_blank" rel="external">https工作原理 </a></li>
<li><a href="http://alvinhu.com/blog/2013/06/20/one-way-and-two-way-ssl-authentication/" target="_blank" rel="external">SSL的单向认证和双向认证</a></li>
<li><a href="http://www.williamlong.info/archives/2058.html" target="_blank" rel="external">破解Google Gmail的https新思路</a></li>
<li><a href="https://yq.aliyun.com/articles/2978" target="_blank" rel="external">淘宝全站HTTPS 百万页面改造技术细节大起底</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近项目中要用到https，找运维人员配置相关参数时，被问到要配置单向认证还是双向认证，瞬间傻了，已是回来研究了下https的原理。</p>
<p>https已经成为电商网站、银行、资金有关的系统的标配，特别是现在网络流量劫持增多、资金频繁被盗等场景下，重要网站https化]]>
    </summary>
    
      <category term="https" scheme="http://wangtianzhi.cn/tags/https/"/>
    
      <category term="网络" scheme="http://wangtianzhi.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="证书" scheme="http://wangtianzhi.cn/tags/%E8%AF%81%E4%B9%A6/"/>
    
      <category term="网络" scheme="http://wangtianzhi.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[springMVC执行流程分析]]></title>
    <link href="http://wangtianzhi.cn/2016/03/05/springmvc-source-analysis/"/>
    <id>http://wangtianzhi.cn/2016/03/05/springmvc-source-analysis/</id>
    <published>2016-03-05T11:00:40.000Z</published>
    <updated>2016-03-05T13:37:14.000Z</updated>
    <content type="html"><![CDATA[<p>springMVC是spring序列的一个web框架，现在已支持restful架构的风格，有取代struts2的趋势。本文只是将网上的一些文章进行总结归纳引用，便于回忆查找。</p>
<h3 id="一-spring版本区别">一.spring版本区别</h3><blockquote>
<ol>
<li>Spring2.5之前，我们都是通过实现Controller接口或其实现来定义我们的处理器类。已经@Deprecated。</li>
<li>Spring2.5引入注解式处理器支持，通过<strong>@Controller</strong> 和 <strong>@RequestMapping</strong>注解定义我们的处理器类。<br>并且提供了一组强大的注解：<ul>
<li><strong>@Controller</strong>：用于标识是处理器类；</li>
<li><strong>@RequestMapping</strong>：请求到处理器功能方法的映射规则；</li>
<li><strong>@RequestParam</strong>：请求参数到处理器功能处理方法的方法参数上的绑定；</li>
<li><strong>@ModelAttribute</strong>：请求参数到命令对象的绑定；</li>
<li><strong>@SessionAttributes</strong>：用于声明session级别存储的属性，放置在处理器类上，通常列出模型属性（如@ModelAttribute）对应的名称，则这些属性会透明的保存到session中；</li>
<li><strong>@InitBinder</strong>：自定义数据绑定注册支持，用于将请求参数转换到命令对象属性的对应类型；<br>注意：需要通过处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter来开启支持@Controller 和@RequestMapping注解的处理器。</li>
</ul>
</li>
<li>Spring3.0引入RESTful架构风格支持(通过@PathVariable注解和一些其他特性支持),且又引入了更多的注解支持：<ul>
<li><strong>@CookieValue</strong>：cookie数据到处理器功能处理方法的方法参数上的绑定；</li>
<li><strong>@RequestHeader</strong>：请求头（header）数据到处理器功能处理方法的方法参数上的绑定；</li>
<li><strong>@RequestBody</strong>：请求的body体的绑定（通过HttpMessageConverter进行类型转换）；</li>
<li><strong>@ResponseBody</strong>：处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；</li>
<li><strong>@ResponseStatus</strong>：定义处理器功能处理方法/异常处理器返回的状态码和原因；</li>
<li><strong>@ExceptionHandler</strong>：注解式声明异常处理器；</li>
<li><strong>@PathVariable</strong>：请求URI中的模板变量部分到处理器功能处理方法的方法参数上的绑定，从而支持RESTful架构风格的URI；</li>
</ul>
</li>
<li>Spring3.1使用新的HandlerMapping 和 HandlerAdapter来支持@Contoller和@RequestMapping注解处理器。<br>新的@Contoller和@RequestMapping注解支持类：处理器映射<strong>RequestMappingHandlerMapping</strong>和处理器适配器<strong>RequestMappingHandlerAdapter</strong>组合来代替Spring2.5开始的处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter，提供更多的扩展点。</li>
</ol>
</blockquote>
<p>配置了<code>&lt;mvc:annotation-driven/&gt;</code>相当于自动加了一堆bean：</p>
<blockquote>
<p>registers a <strong>RequestMappingHandlerMapping</strong>, a <strong>RequestMappingHandlerAdapter</strong>, and an <strong>ExceptionHandlerExceptionResolver</strong> (among others) in support of processing requests with annotated controller methods using annotations such as @RequestMapping, @ExceptionHandler, and others.</p>
<p>It also enables the following:</p>
<ul>
<li>Spring 3 style type conversion through a ConversionService instance in addition to the JavaBeans PropertyEditors used for Data Binding.</li>
<li>Support for formatting Number fields using the @NumberFormat annotation through the ConversionService.</li>
<li>Support for formatting Date, Calendar, Long, and Joda Time fields using the @DateTimeFormat annotation.</li>
<li>Support for validating @Controller inputs with @Valid, if a JSR-303 Provider is present on the classpath.</li>
<li><strong>HttpMessageConverter</strong> support for @RequestBody method parameters and @ResponseBody method return values from @RequestMapping or @ExceptionHandler methods.</li>
</ul>
<p>This is the complete list of HttpMessageConverters set up by mvc:annotation-driven:</p>
<ul>
<li>ByteArrayHttpMessageConverter converts byte arrays.</li>
<li>StringHttpMessageConverter converts strings.</li>
<li>ResourceHttpMessageConverter converts to/from org.springframework.core.io.Resource for all media types.</li>
<li>SourceHttpMessageConverter converts to/from a javax.xml.transform.Source.</li>
<li>FormHttpMessageConverter converts form data to/from a MultiValueMap.</li>
<li>Jaxb2RootElementHttpMessageConverter converts Java objects to/from XML — added if JAXB2 is present and Jackson 2 XML extension is not present on the classpath.</li>
<li>MappingJackson2HttpMessageConverter converts to/from JSON — added if Jackson 2 is present on the classpath.</li>
<li>MappingJackson2XmlHttpMessageConverter converts to/from XML — added if Jackson 2 XML extension is present on the classpath.</li>
<li>AtomFeedHttpMessageConverter converts Atom feeds — added if Rome is present on the classpath.</li>
<li>RssChannelHttpMessageConverter converts RSS feeds — added if Rome is present on the classpath.</li>
</ul>
</blockquote>
<p>当然，也可以自己自定义各种配置，具体的方法可以参考<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html" target="_blank" rel="external">springMVC docs</a>;</p>
<h3 id="二-springMVC执行流程">二.springMVC执行流程</h3><p><img src="/img/springmvc-source-analysis/springmvc-request-process.JPG" alt="图片来自跟开涛学springmvc"></p>
<p>核心架构的具体流程步骤如下：</p>
<blockquote>
<ol>
<li>首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</li>
<li>DispatcherServlet——&gt;HandlerMapping， HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</li>
<li>DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</li>
<li>HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</li>
<li>ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</li>
<li>View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</li>
<li>返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</li>
</ol>
</blockquote>
<h3 id="三-_源码分析">三. 源码分析</h3><p>处理的核心代码在DispatcherServlet的doDispatch方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">////检查是否是请求是否是multipart（如文件上传），如果是将通过MultipartResolver解析</span></span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = processedRequest != request;</span><br><span class="line"></span><br><span class="line"><span class="comment">// //步骤2、请求到处理器（页面控制器）的映射，通过HandlerMapping进行映射</span></span><br><span class="line">mappedHandler = getHandler(processedRequest, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3、处理器适配，即将我们的处理器包装成相应的适配器（从而支持多种类型的处理器）</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">String requestUri = urlPathHelper.getRequestUri(request);</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + requestUri + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行处理器相关的拦截器的预处理（HandlerInterceptor.preHandle）</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//步骤4、由适配器执行处理器（调用处理器相应功能处理方法） </span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyDefaultViewName(request, mv);</span><br><span class="line"><span class="comment">//执行处理器相关的拦截器的后处理（HandlerInterceptor.postHandle）</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//步骤5 由ViewResolver解析View（viewResolver.resolveViewName(viewName, locale)）  </span></span><br><span class="line"><span class="comment">//步骤6 视图在渲染时会把Model传入（view.render(mv.getModelInternal(), request, response);）</span></span><br><span class="line"><span class="comment">//HandlerInterceptor.afterCompletion</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>步骤4调用handle来真正执行响应的controller的方法，在此过程中还会调用convert进行类型转换等操作，若添加了<code>&lt;mvc:annotation-driven/&gt;</code>的配置，如果maven引用了Jackson 2包，则会调用<code>MappingJackson2HttpMessageConverter</code>这个converter进行json和对象的间的转换。</p>
<p>步骤5中ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术，如JSP、freemarker等;步骤6会根据传进来的Model模型数据进行渲染。</p>
<p>在方法的执行前后，还会调用拦截器的相关方法：</p>
<p><strong>拦截器接口：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(  </span><br><span class="line">HttpServletRequest request, HttpServletResponse response,   </span><br><span class="line">Object handler)</span>   </span><br><span class="line"><span class="keyword">throws</span> Exception</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(  </span><br><span class="line">HttpServletRequest request, HttpServletResponse response,   </span><br><span class="line">Object handler, ModelAndView modelAndView)</span>   </span><br><span class="line"><span class="keyword">throws</span> Exception</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(  </span><br><span class="line">HttpServletRequest request, HttpServletResponse response,   </span><br><span class="line">Object handler, Exception ex)</span>  </span><br><span class="line"><span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>preHandle</strong>：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器（如我们上一章的Controller实现）；返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；</p>
<p><strong>postHandle</strong>：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null；</p>
<p><strong>afterCompletion</strong>：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。</p>
<h3 id="四-_struts2_vs_springMVC">四. struts2 vs springMVC</h3><p><img src="/img/springmvc-source-analysis/struts2-framework.png" alt="struts2框架图"></p>
<ol>
<li>struts2是一个请求一个action，springmvc是单实例的；</li>
<li>struts2是基于类的横切，springmvc是基于方法的，粒度更细；</li>
<li>一个入口是filter，一个入口是servlet，两者各方面实现机制不一样；</li>
<li>springMVC开发速度和性能由于struts2（不过springMVC性能比struts1差）；</li>
<li>spring体系更加强大和活跃；</li>
<li>注解功能强大，支持restful等；</li>
<li>struts2更新慢，且经常曝出漏洞，风险大；</li>
</ol>
<h3 id="五-_参考文献">五. 参考文献</h3><ol>
<li><a href="http://jinnianshilongnian.iteye.com/blog/1670856" target="_blank" rel="external">拦截器介绍</a></li>
<li><a href="http://www.chawenti.com/articles/23596.html" target="_blank" rel="external">SpringMVC关于json、xml自动转换的原理研究</a></li>
<li><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html" target="_blank" rel="external">springMVC doc</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/web/wa-restful/" target="_blank" rel="external">使用 Spring 3 MVC HttpMessageConverter 功能构建 RESTful web 服务</a></li>
<li><a href="http://blog.csdn.net/gstormspire/article/details/8239182" target="_blank" rel="external">SpringMVC与Struts2的对比</a></li>
<li><a href="http://jinnianshilongnian.iteye.com/blog/1752171" target="_blank" rel="external">跟开涛学SpringMVC</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>springMVC是spring序列的一个web框架，现在已支持restful架构的风格，有取代struts2的趋势。本文只是将网上的一些文章进行总结归纳引用，便于回忆查找。</p>
<h3 id="一-spring版本区别">一.spring版本区别</h3><block]]>
    </summary>
    
      <category term="springmvc" scheme="http://wangtianzhi.cn/tags/springmvc/"/>
    
      <category term="web" scheme="http://wangtianzhi.cn/tags/web/"/>
    
      <category term="web开发" scheme="http://wangtianzhi.cn/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[web与spring初始化过程分析]]></title>
    <link href="http://wangtianzhi.cn/2016/03/03/web-init-process/"/>
    <id>http://wangtianzhi.cn/2016/03/03/web-init-process/</id>
    <published>2016-03-03T13:58:40.000Z</published>
    <updated>2016-03-05T08:53:18.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一-总体初始化流程">一.总体初始化流程</h3><p>web.xml加载顺序，context-param -&gt; listener -&gt; filter -&gt; servlet；</p>
<ol>
<li><p>启动一个WEB项目的时候，WEB容器会去读取它的配置文件web.xml，读取<listener>和<context-param>两个结点；</context-param></listener></p>
</li>
<li><p>紧接着，容器创建一个ServletContext（servlet上下文），这个web项目的所有部分都将共享这个上下文；</p>
</li>
<li><p>容器将<context-param>转换为键值对，并交给servletContext；</context-param></p>
</li>
<li><p>容器创建<listener>中的类实例，创建监听器。（如spring的ContextLoadListener、RequestContextListener、Log4jConfigListener等）（ContextLoadListener实例化Ioc容器，根据条件决定是否此时实例化bean，如lazy-init,scope等参数）；</listener></p>
</li>
<li><p>构建filter链（如CharacterEncodingFilter、OpenSessionInViewFilter、struts2的StrutsPrepareFilter、StrutsExecuteFilter等）；</p>
</li>
</ol>
<p>注意：<strong>servlet是单实例多线程；spring bean默认也是单实例的，不过可以通过scope参数来设置为别的；struts2中action是多例的</strong>。另外，本文基于spring3.2.2源码来分析的。</p>
<h3 id="二-详细解析">二.详细解析</h3><p><strong>servlet、listener、filter的关键方法</strong></p>
<p><strong>Servlet</strong><br>-init(ServletConfig config)<br>-service(ServletRequest req, ServletResponse res)<br>//service再根据请求类型调用doGet、doPost等方法<br>-destroy()</p>
<p><strong>Listener</strong><br>ServletContextListener<br>-contextInitialized ( ServletContextEvent sce )<br>-contextDestroyed ( ServletContextEvent sce )<br>ServletRequestListener<br>-requestInitialized(ServletRequestEvent requestEvent)<br>-requestDestroyed(ServletRequestEvent requestEvent)</p>
<p><strong>Filter</strong><br>-init(FilterConfig filterConfig)<br>-destroy()<br>-doFilter(ServletRequest request, ServletResponse response, FilterChain chain)  </p>
<h4 id="1-Spring-ContextLoaderListener">1.Spring-ContextLoaderListener</h4><p><code>ContextLoaderListener</code>作用就是启动Web容器时，自动装配spring的配置文件的配置信息；<br><code>ContextLoaderServlet</code>:与ContextLoaderListener功能一样；</p>
<p>ContextLoaderListener它继承了<code>javax.servlet.ServletContextListener</code>接口。ServletContextListener是J2EE Servlet API中的一个标准接口，它能够监听ServletContext对象的生命周期，实际上就是监听Web应用的生命周期。当Servlet容器<strong>启动或终止</strong>Web应用时，会触发ServletContextEvent事件，该事件由ServletContextListener来处理。</p>
<p>Ioc容器实例化流程如图所示：<br><img src="/img/web-init-process/spring-start-up.png" alt="ContextLoaderListener初始化调用流程"><br>实例化Spring IoC容器的过程中，最主要的两个方法是<code>createWebApplicationContext</code>和<code>configureAndRefreshWebApplicationContext</code>方法。</p>
<p><code>createWebApplicationContext</code>方法用于返回XmlWebApplicationContext实例，即Web环境下的Spring IoC容器。</p>
<p><code>configureAndRefreshWebApplicationContext</code>用于配置XmlWebApplicationContext，读取web.xml中通过<code>contextConfigLocation</code>标签指定的XML文件，实例化XML文件中配置的bean，并在上一步中实例化的容器中进行注册。</p>
<p>完成以上两步的操作后，Spring MVC会将XmlWebApplicationContext实例以属性的方式注册到ServletContext中。此Spring 容器是ROOT上下文，供所有的Spring MVC Servlcet使用。<br>核心的初始化逻辑都在AbstractApplicationContext的<code>refresh()</code>方法里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"><span class="comment">// 注册实现了BeanPostProcessor接口的bean</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化和执行BeanFactoryPostProcessor beans</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化和执行BeanPostProcessor beans</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化non-lazy-init的单例bean.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>obtainFreshBeanFactory()方法会刷新所有BeanFactory子容器，在此会<strong>加载、解析Bean</strong>的定义。<br>finishBeanFactoryInitialization()方法用来<strong>实例化bean</strong>。</p>
<p><strong>bean实例化时机：</strong><br>若是单例、lazy-init=false且不是抽象类，则实例化,否则等到执行时才实例化；实例化中若有依赖别的bean，需要先实例化依赖的bean。<br>具体代码逻辑在<code>DefaultListableBeanFactory</code>的<code>preInstantiateSingletons()</code>和<code>AbstractBeanFactory</code>的<code>doGetBean()</code>，可以参考<a href="http://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/" target="_blank" rel="external">Spring 框架的设计理念与设计模式分析</a>。</p>
<p><strong>ApplicationContext vs BeanFactory</strong><br>ApplicationContext的类继承关系如图所示：<br><img src="/img/web-init-process/spring-applicationcontext-diagram.png" alt="ApplicationContext类继承关系"><br><code>ApplicationContext</code> 由BeanFactory 派生而来，提供了更多面向实际应用的功能。几乎所有的应用场合我们都直接使用<code>ApplicationContext</code> 而非底层的BeanFactory。在BeanFactory 中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置的方式实现。</p>
<p>ApplicationContext的主要实现类是<code>ClassPathXmlApplicationContext</code> 和<code>FileSystemXmlApplicationContext</code>，前者默认从类路径加载配置文件，后者默认从文件系统中装载配置文件。</p>
<p><code>WebApplicationContext</code> 是专门为Web 应用准备的，WebApplicationContext 扩展了ApplicationContext。<br>Spring 分别提供了用于启动WebApplicationContext 的Servlet 和Web 容器监听器：</p>
<blockquote>
<p>org.springframework.web.context.ContextLoaderServlet；<br>org.springframework.web.context.ContextLoaderListener;</p>
</blockquote>
<p>两者的内部都实现了启动WebApplicationContext 实例的逻辑，我们只要根据Web 容器的具体情况选择两者之一，并在web.xml 中完成配置就可以了。  </p>
<h4 id="2-SpringMVC-DispatcherServlet">2.SpringMVC-DispatcherServlet</h4><p>DispatcherServlet配置在web.xml中，是springmvc的入口，它的继承关系图如下图所示：<br><img src="/img/web-init-process/dispatcherServlet类继承图.png" alt="DispatcherServlet类继承图"></p>
<ol>
<li>HttpServletBean继承HttpServlet，因此在Web容器启动时将调用它的init方法，该初始化方法的主要作用：<br>a. 将Servlet初始化参数（init-param）设置到该组件上（如contextAttribute、contextClass、namespace、contextConfigLocation），通过BeanWrapper简化设值过程，方便后续使用；<br>b. 提供给子类初始化扩展点，initServletBean()，该方法由FrameworkServlet覆盖。</li>
<li>FrameworkServlet继承HttpServletBean，通过initServletBean()进行Web上下文初始化，该方法主要覆盖一下两件事情：<br>a. 初始化web上下文；<br>b. 提供给子类初始化扩展点；</li>
<li>DispatcherServlet继承FrameworkServlet，并实现了onRefresh()方法提供一些前端控制器相关的配置：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line"><span class="comment">//实现子类的onRefresh()方法，该方法委托为initStrategies()方法。</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//初始化默认的Spring Web MVC框架使用的策略（如HandlerMapping）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line">initHandlerMappings(context);</span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从如上代码可以看出，DispatcherServlet启动时会进行我们需要的Web层Bean的配置，如HandlerMapping、HandlerAdapter等，而且如果我们没有配置，还会给我们提供默认的配置。</p>
<p>从如上代码我们可以看出，整个DispatcherServlet初始化的过程和做了些什么事情，具体主要做了如下两件事情：</p>
<ol>
<li>初始化Spring Web MVC使用的Web上下文，并且可能指定父容器为（ContextLoaderListener加载了根上下文）；</li>
<li>初始化DispatcherServlet使用的策略，如HandlerMapping、HandlerAdapter等。</li>
</ol>
<h4 id="3-Spring-RequestContextListener">3.Spring-RequestContextListener</h4><p>ContextLoaderListener实现ServletContextListener监听器接口，而ServletContextListener只负责监听Web容器的启动和关闭的事件。RequestContextListener实现ServletRequestListener监听器接口，该监听器监听HTTP请求事件，Web服务器接收的每次请求都会通知该监听器。</p>
<h4 id="4-其它的一些类">4.其它的一些类</h4><p>1）CharacterEncodingFilter：字符编码转换filter，这个filter一定要注意顺序，要放在其它filter前面，要不然可能不起作用；</p>
<p>2） OpenSessionInViewFilter：主要功能是用来把一个Hibernate Session和一次完整的请求过程对应的线程相绑定。跟延迟加载相关。</p>
<p>3） Struts2的入口：StrutsPrepareFilter、StrutsExecuteFilter、StrutsListener</p>
<h3 id="三-_参考文献">三. 参考文献</h3><ol>
<li><a href="http://blog.csdn.net/hongshan50/article/details/7335443" target="_blank" rel="external">web.xml加载顺序</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/" target="_blank" rel="external">Spring 框架的设计理念与设计模式分析</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/" target="_blank" rel="external">Servlet 工作原理解析</a></li>
<li><a href="http://jinnianshilongnian.iteye.com/blog/1602617" target="_blank" rel="external">第三章 DispatcherServlet详解 ——跟开涛学SpringMVC</a> </li>
<li>&lt;深入分析JAVA web技术内幕-许令波&gt;</li>
<li><a href="http://spring.io/docs/" target="_blank" rel="external">spring docs</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一-总体初始化流程">一.总体初始化流程</h3><p>web.xml加载顺序，context-param -&gt; listener -&gt; filter -&gt; servlet；</p>
<ol>
<li><p>启动一个WEB项目的时候，WEB容器会]]>
    </summary>
    
      <category term="spring" scheme="http://wangtianzhi.cn/tags/spring/"/>
    
      <category term="springmvc" scheme="http://wangtianzhi.cn/tags/springmvc/"/>
    
      <category term="web" scheme="http://wangtianzhi.cn/tags/web/"/>
    
      <category term="web开发" scheme="http://wangtianzhi.cn/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[netty源码分析]]></title>
    <link href="http://wangtianzhi.cn/2016/02/04/netty-source-analysis/"/>
    <id>http://wangtianzhi.cn/2016/02/04/netty-source-analysis/</id>
    <published>2016-02-04T13:39:19.000Z</published>
    <updated>2016-02-05T11:57:08.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-netty概述">一.netty概述</h4><p>java nio是jdk1.4引入的网络编程API，相比于以前BIO阻塞方式的接口，能大大提高网络通信的效率。</p>
<p>netty是一个网络通信框架，底层基于java NIO，用来简化NIO编程的开发。因为如果基于NIO直接实现网络编程的开发，比较复杂，很容易出错，而使用了netty之后，只需要关注逻辑处理部分就可以了。此外，netty还提供了多种网络协议的封装。</p>
<p>Netty4的beta3加了AIO了,但是到beta9又去掉了,作者的意思是测试下来AIO性能不如NIO,所以没必要用。</p>
<p>NIO和AIO在linux中底层都是依赖于epoll来实现的。NIO的模型应该为同步非阻塞，AIO为异步非阻塞。底层的具体实现可以参考前面的文章。</p>
<p>本文基于netty4.0源码来分析netty的网络通信模型。</p>
<h4 id="二-channel和channelPipeline">二.channel和channelPipeline</h4><p>在Netty里，Channel是通讯的载体，而ChannelHandler负责Channel中的逻辑处理,channelPipeline可以理解为channel的载体，每个channel都有一个对应的ChannelPipeline。</p>
<p>一个channel包括一个pipeline、TCP参数、一个unsafe等，netty4的channel类图如下所示：<br><img src="/img/netty-channel类图.png" alt="netty4的channel类图"></p>
<p>按IO类型可以分为:BIO和NIO。<br>按数据类型可以分为:byte,message。<br>按所处位置可以分为:ServerSocket,Socket。用的比较多的为NioServerSocketChannel和NioSocketChannel。</p>
<p>NioServerSocketChannel继承了AbstractNioMessageChannel，而NioSocketChannel继承了AbstractNioByteChannel。</p>
<p>netty通过一序列的ChannelHandler来处理一个任务，比如read一条消息后，需要decode、验证、计算等各个步骤。在handler中，每个步骤可以写成一个handler。这一序列的handler通过ChannelPipeline串联起来，其实就是Intercepting Filter模式。</p>
<p>ChannelPipeline通过一个双向链表将handler连接起来，在ChannelPipeline里有headContext和tailContext两个handler，来分别表示链表的头和尾，通过ChannelPipeline来控制消息的处理流程。</p>
<p>一个IO事件会被ChannelInboundHandler或ChannelOutboundHandler处理，这些handler再通过调用事件传播方法如fireChannelRegistered或bind等传递给相邻的handler，其实就是事件驱动的思想。</p>
<p>Netty的ChannelPipeline包含两条线路：inbound和outbound。inbound表示接收到消息、被动的消息，outbound表示发送的消息、主动的状态改变。一个handler可以包括inbound和outbound的一种或两种。</p>
<p>inbound的事件传播方法包括以下几种情况：</p>
<blockquote>
<p>fireChannelRegistered<br>fireChannelActive<br>fireChannelRead<br>fireChannelReadComplete<br>fireExceptionCaught<br>fireUserEventTriggered<br>fireChannelWritabilityChanged<br>fireChannelInactive<br>fireChannelUnregistered</p>
</blockquote>
<p>outbound的事件传播方法包括以下几种情况：  </p>
<blockquote>
<p>bind<br>connect<br>write<br>flush<br>read<br>disconnect<br>close<br>deregister</p>
</blockquote>
<p>例如，有一个称为p的ChannelPipeline,添加了如下的handler:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.addLast(<span class="string">"1"</span>, <span class="keyword">new</span> InboundHandlerA());  </span><br><span class="line">p.addLast(<span class="string">"2"</span>, <span class="keyword">new</span> InboundHandlerB());  </span><br><span class="line">p.addLast(<span class="string">"3"</span>, <span class="keyword">new</span> OutboundHandlerA());  </span><br><span class="line">p.addLast(<span class="string">"4"</span>, <span class="keyword">new</span> OutboundHandlerB());  </span><br><span class="line">p.addLast(<span class="string">"5"</span>, <span class="keyword">new</span> InboundOutboundHandlerX());</span><br></pre></td></tr></table></figure>
<p>则现在的链表结构为：head&lt;-&gt;5&lt;-&gt;4&lt;-&gt;3&lt;-&gt;2&lt;-&gt;1&lt;-&gt;tail （注意，每次添加handler都是插入到tail的前面），inbound的执行顺序为5、2、1，而outbound的执行顺序为3、4、5.</p>
<p>下图为从源码注解截取的pipeline流程图：<br><img src="/img/netty-channelpipeline流程图.png" alt="pipeline传播流程"></p>
<h4 id="三-handler">三.handler</h4><p>handler的类图如下所示：<br><img src="/img/netty-handler类图.png" alt="netty4的handler类图"><br>HeadContext和TailContext为pipeline的handler链表中的表头和表尾。此外，netty还提供了很多协议（如protobuf、mqtt、socks等等）的handler用来处理encode、decode等的功能。</p>
<h4 id="四-buffer">四.buffer</h4><p>buffer的缓存分配器和buffer类图如下所示：<br><img src="/img/netty-bytebuffallocator类图.png" alt="netty4的ByteBuffAllocator"><br><img src="/img/netty-buffer类图.png" alt="netty4的buffer类图"></p>
<p>除了可分配定长的buffer外，netty还提供了AdaptiveRecvByteBufAllocator，用来根据本次读取的字节数对下次缓冲接收区的容量进行动态的分配。具体如何分配可参考参考文献3的文档。为了提高效率，netty还提供了基于内存池的缓冲区重用策略（可参考<a href="http://www.infoq.com/cn/articles/netty-high-performance" target="_blank" rel="external">Netty系列之Netty高性能之道</a>一文）。</p>
<p>此外，netty还采用了”Zero-Copy-Capable”机制。我们知道一个报文在网络上传输有可能被拆分成多个，这些被拆分的报文对接收到的上层的逻辑是没有意义的，在netty中，通过将这些buffer组合起来，成为一个channelbuffer，变成一个有意义的报文。当然，zero-copy的含义不止这个，netty的zero-copy机制的具体体现参见李林锋大神的<a href="http://www.infoq.com/cn/articles/netty-high-performance" target="_blank" rel="external">Netty系列之Netty高性能之道</a>一文。如果说NIO的Buffer和Netty的ChannelBuffer最大的区别的话，就是前者仅仅是传输上的Buffer，而后者其实是传输Buffer和抽象后的逻辑Buffer的结合。</p>
<p>例如CompositeChannelBuffer是由多个ChannelBuffer组合而成的，CompositeChannelBuffer并不会开辟新的内存并直接复制所有ChannelBuffer内容，而是直接保存了所有ChannelBuffer的引用，并在子ChannelBuffer里进行读写。当然，要真正zero-copy可能要底层系统支持，下文是stackoverflow上的关于OS级别的zero-copy和netty的区别：</p>
<blockquote>
<p>OS-level zero copy involves avoiding copying memory blocks from one location to another (typically from user space to kernel space) before sending data to the hardware driver (network card or disk drive) or vice versa.  </p>
<p>Netty zero copy is talking about optimizing data manipulation on Java level (user-space only). Their ChannelBuffer allows to read contents of multiple byte buffers without actually copying their content.</p>
<p>In other words, while Netty works only in user space, it is still valid to call their approach “zero copy”.<br>However, if OS does not use or support true zero copy, it is possible that when data created by Netty-powered program will be sent over the network, data would still be copied from user space to kernel space, and thus true zero-copy would not be achieved.</p>
</blockquote>
<h4 id="五-netty线程模型">五.netty线程模型</h4><p>对于应用服务器，一个主要规律就是，CPU的处理速度是要远远快于IO速度的，如果CPU为了IO操作（例如从Socket读取一段数据）而阻塞显然是不划算的。好一点的方法是分为多进程或者线程去进行处理，但是这样会带来一些进程切换的开销。应用业务向一个中间人注册一个回调（event handler），当IO就绪后，就这个中间人产生一个事件，并通知此handler进行处理。这种回调的方式，也体现了“好莱坞原则”（Hollywood principle）-“Don’t call us, we’ll call you”。</p>
<p>我们如何知道IO就绪这个事件，谁来充当这个中间人？<strong>Reactor</strong>模式的答案是：由一个不断等待和循环的单独进程（线程）来做这件事，它接受所有handler的注册，并负责先操作系统查询IO是否就绪，在就绪后就调用指定handler进行处理，这个角色的名字就叫做Reactor。在NIO中Reactor的核心是Selector。</p>
<p>Reactor模式里，操作系统只负责通知IO就绪，具体的IO操作（例如读写）仍然是要在业务进程里阻塞的去做的，而<strong>Proactor</strong>模式则更进一步，由操作系统将IO操作执行好（例如读取，会将数据直接读到内存buffer中），而handler只负责处理自己的逻辑，真正做到了IO与程序处理异步执行。所以我们一般又说Reactor是同步IO，Proactor是异步IO。</p>
<p>如下是netty4.0源码的一个server端的例子（EchoServer）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">	b.group(bossGroup, workerGroup)</span><br><span class="line">	 .channel(NioServerSocketChannel.class)</span><br><span class="line">	 .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">	 .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">	 .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">		 <span class="annotation">@Override</span></span><br><span class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			 ChannelPipeline p = ch.pipeline();</span><br><span class="line">			 <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">				 p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">			 p.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the server.</span></span><br><span class="line">	ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line">	<span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">	f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">	bossGroup.shutdownGracefully();</span><br><span class="line">	workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是client端的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configure the client.</span></span><br><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">	b.group(group)</span><br><span class="line">	 .channel(NioSocketChannel.class)</span><br><span class="line">	 .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">	 .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">		 <span class="annotation">@Override</span></span><br><span class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			 ChannelPipeline p = ch.pipeline();</span><br><span class="line">			 <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">				 p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">			 p.addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the client.</span></span><br><span class="line">	ChannelFuture f = b.connect(HOST, PORT).sync();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait until the connection is closed.</span></span><br><span class="line">	f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// Shut down the event loop to terminate all threads.</span></span><br><span class="line">	group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在server端，可以看到有两个NioEventLoopGroup，这两个其实就是两组线程组，称为boss和worker。boss和worker里面都可以包含多个NioEventLoop线程，一般boss设置1个线程就够了，一个线程绑定一个端口，而worker默认的线程数量为cpu个数的2倍。每个EventLoop线程有一个selector和queue,该线程会轮询绑定到此selector的channel，收到绑定的事件后，会触发发事件通知handler处理。</p>
<p>在初始化时，会将NioServerSocketChannel放进boss线程池中的一个eventLoop线程，让eventLoop关联的select轮询，处理client的connect。boss负责接收connect，接收到connect后，new一个NioSocketChannel，并放进worker的一个线程中，让对应的selector轮询处理read、write等操作。</p>
<p>线程模型如下图所示：<br><img src="/img/netty-线程模型图.png" alt="netty4线程模型"><br>注：一个channel包含一个pipeline、TCP参数、unsafe等，一个worker包含多个EventLoop线程，一个EventLoop包含一个selector、一个queue。</p>
<p>上述只是netty常用的一种线程模型，netty可以根据不同的配置，演变出其他的线程模型（可以参考<a href="http://www.infoq.com/cn/articles/netty-high-performance" target="_blank" rel="external">Netty系列之Netty高性能之道</a>一文）。</p>
<p>此外，netty还采用了很多方法来提高netty的性能，如高效的并发编程、高性能的序列化框架、灵活的TCP参数配置能力等。</p>
<p>下面附上网上一个大神(<a href="http://xw-z1985.iteye.com/blog/1973205" target="_blank" rel="external">海浪儿</a>)总结的上文所述例子的执行过程，具体源码的解析可以参考参考文献2.</p>
<blockquote>
<p><strong>服务端依次发生的步骤</strong>  </p>
<ol>
<li>建立服务端监听套接字ServerSocketChannel，以及对应的管道pipeline；  </li>
<li>启动boss线程，将ServerSocketChannel注册到boss线程持有的selector中，并将注册返回的selectionKey赋值给ServerSocketChannel关联的selectionKey变量；  </li>
<li>在ServerSocketChannel对应的管道中触发channelRegistered事件；  </li>
<li>绑定IP和端口  </li>
<li>触发channelActive事件，并将ServerSocketChannel关联的selectionKey的OP_ACCEPT位置为1。  </li>
<li>客户端发起connect请求后，boss线程正在运行的select循环检测到了该ServerSocketChannel的ACCEPT事件就绪，则通过accept系统调用建立一个已连接套接字SocketChannel，并为其创建对应的管道；  </li>
<li>在服务端监听套接字对应的管道中触发channelRead事件；  </li>
<li>channelRead事件由ServerBootstrapAcceptor的channelRead方法响应：为已连接套接字对应的管道加入ChannelInitializer处理器；启动一个worker线程，并将已连接套接字的注册任务加入到worker线程的任务队列中；  </li>
<li>worker线程执行已连接套接字的注册任务：将已连接套接字注册到worker线程持有的selector中，并将注册返回的selectionKey赋值给已连接套接字关联的selectionKey变量；在已连接套接字对应的管道中触发channelRegistered事件；channelRegistered事件由ChannelInitializer的channelRegistered方法响应：将自定义的处理器（譬如EchoServerHandler）加入到已连接套接字对应的管道中；在已连接套接字对应的管道中触发channelActive事件；channelActive事件由已连接套接字对应的管道中的inbound处理器的channelActive方法响应；将已连接套接字关联的selectionKey的OP_READ位置为1；至此，worker线程关联的selector就开始监听已连接套接字的READ事件了。  </li>
<li>在worker线程运行的同时，Boss线程接着在服务端监听套接字对应的管道中触发channelReadComplete事件。  </li>
<li>客户端向服务端发送消息后，worker线程正在运行的selector循环会检测到已连接套接字的READ事件就绪。则通过read系统调用将消息从套接字的接受缓冲区中读到AdaptiveRecvByteBufAllocator（可以自适应调整分配的缓存的大小）分配的缓存中；  </li>
<li>在已连接套接字对应的管道中触发channelRead事件；  </li>
<li>channelRead事件由EchoServerHandler处理器的channelRead方法响应：执行write操作将消息存储到ChannelOutboundBuffer中；  </li>
<li>在已连接套接字对应的管道中触发ChannelReadComplete事件；  </li>
<li>ChannelReadComplete事件由EchoServerHandler处理器的channelReadComplete方法响应：执行flush操作将消息从ChannelOutboundBuffer中flush到套接字的发送缓冲区中；  </li>
</ol>
<p><strong>客户端依次发生的步骤</strong>  </p>
<ol>
<li>建立套接字SocketChannel，以及对应的管道pipeline；  </li>
<li>启动客户端线程，将SocketChannel注册到客户端线程持有的selector中，并将注册返回的selectionKey赋值给SocketChannel关联的selectionKey变量；  </li>
<li>触发channelRegistered事件；  </li>
<li>channelRegistered事件由ChannelInitializer的channelRegistered方法响应：将客户端自定义的处理器（譬如EchoClientHandler）按顺序加入到管道中；  </li>
<li>向服务端发起connect请求，并将SocketChannel关联的selectionKey的OP_CONNECT位置为1；  </li>
<li>开始三次握手，客户端线程正在运行的select循环检测到了该SocketChannel的CONNECT事件就绪，则将关联的selectionKey的OP_CONNECT位置为0，再通过调用finishConnect完成连接的建立；  </li>
<li>触发channelActive事件；  </li>
<li>channelActive事件由EchoClientHandler的channelActive方法响应，通过调用ctx.writeAndFlush方法将消息发往服务端；  </li>
<li>首先将消息存储到ChannelOutboundBuffer中；（如果ChannelOutboundBuffer存储的所有未flush的消息的大小超过高水位线writeBufferHighWaterMark（默认值为64 * 1024），则会触发ChannelWritabilityChanged事件）  </li>
<li>然后将消息从ChannelOutboundBuffer中flush到套接字的发送缓冲区中；（如果ChannelOutboundBuffer存储的所有未flush的消息的大小小于低水位线，则会触发ChannelWritabilityChanged事件）  </li>
</ol>
</blockquote>
<h4 id="六-参考文献">六.参考文献</h4><ol>
<li>netty源码解析 <a href="https://github.com/code4craft/netty-learning" target="_blank" rel="external">https://github.com/code4craft/netty-learning</a>  </li>
<li><strong>netty4.x源码分析</strong> <a href="http://xw-z1985.iteye.com/blog/1918052" target="_blank" rel="external">http://xw-z1985.iteye.com/blog/1918052</a>  </li>
<li>Netty5.0架构剖析和源码解读 <a href="http://vdisk.weibo.com/s/C9LV9iVqH13rW/1391437855" target="_blank" rel="external">http://vdisk.weibo.com/s/C9LV9iVqH13rW/1391437855</a>  </li>
<li>netty user guide <a href="http://netty.io/wiki/user-guide-for-4.x.html" target="_blank" rel="external">http://netty.io/wiki/user-guide-for-4.x.html</a></li>
<li><strong>Netty系列之Netty高性能之道</strong> <a href="http://www.infoq.com/cn/articles/netty-high-performance" target="_blank" rel="external">http://www.infoq.com/cn/articles/netty-high-performance</a></li>
<li>《netty权威指南》-李林锋</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="一-netty概述">一.netty概述</h4><p>java nio是jdk1.4引入的网络编程API，相比于以前BIO阻塞方式的接口，能大大提高网络通信的效率。</p>
<p>netty是一个网络通信框架，底层基于java NIO，用来简化NIO编程的开发。]]>
    </summary>
    
      <category term="NIO" scheme="http://wangtianzhi.cn/tags/NIO/"/>
    
      <category term="netty" scheme="http://wangtianzhi.cn/tags/netty/"/>
    
      <category term="网络" scheme="http://wangtianzhi.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="netty" scheme="http://wangtianzhi.cn/categories/netty/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UNIX IO模型]]></title>
    <link href="http://wangtianzhi.cn/2016/01/25/unix-io-mode/"/>
    <id>http://wangtianzhi.cn/2016/01/25/unix-io-mode/</id>
    <published>2016-01-25T12:39:19.000Z</published>
    <updated>2016-01-25T14:07:57.000Z</updated>
    <content type="html"><![CDATA[<p>在研究nio和netty时，对它们的底层实现不是很了解，因此查阅了相关的资料，总结了在操作系统层面的IO通信模型。本文主要是基于unix环境来介绍，毕竟平常的服务器很少用windows的环境当服务器。要想深入的学习网络编程还得看看《unix网络编程》这本大名鼎鼎的书（包括卷一和卷二两本）。</p>
<h4 id="一-概念理解">一.概念理解</h4><p><strong>1.阻塞与非阻塞</strong></p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。<br>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<p><strong>2.同步与异步</strong></p>
<p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</p>
<p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。<br>例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕。</p>
<p><strong>一个IO操作其实分成了两个步骤：发起IO请求(是否阻塞等待数据，来区分阻塞与非阻塞IO)和实际的IO操作（将数据从内核空间拷贝到用户空间，是否阻塞用来区分同步还是异步）。</strong></p>
<p>阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。</p>
<p>同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此下文将要介绍的IO模型中阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO，IO模型中的异步IO就是异步的。  </p>
<h4 id="二-_UNIX网络IO模型">二. UNIX网络IO模型</h4><p>Linux的内核将所有外部设备都可以看做一个文件来操作，那么我们对与外部设备的操作都可以看做对文件进行操作。我们对一个文件的读写，都通过调用内核提供的系统调用；内核给我们返回一个file descriptor（fd,文件描述符）。而对一个socket的读写也会有相应的描述符，称为socketfd（socket描述符），描述符就是一个数字，指向内核中一个结构体（文件路径，数据区等一些属性）。</p>
<p><strong>1.阻塞I/O（blocking I/O）</strong></p>
<p>以socket为例，在进程空间中调用recvfrom,其系统调用直到数据报到达且被拷贝到应用进程的缓冲区中或者发生错误才返回，期间一直在等待。<br><img src="/img/阻塞式IO模型.png" alt="阻塞IO模型"></p>
<p><strong>2.非阻塞I/O （nonblocking I/O）</strong></p>
<p>recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，一般都对非阻塞IO模型进行轮询检查这个状态，看内核是不是有数据到来。<br><img src="/img/非阻塞式IO模型.png" alt="非阻塞IO模型"><br><strong>3. I/O复用(select 和poll) （I/O multiplexing）</strong></p>
<p>Linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select；这样select/poll可以帮我们侦测许多fd是否就绪。但是select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限。linux还提供了一个epoll系统调用，epoll是基于事件驱动方式，而不是顺序扫描，当有fd就绪时，立即回调函数rollback。<br><img src="/img/IO复用模型.png" alt="IO复用模型"></p>
<p><strong>4.信号驱动I/O （signal driven I/O (SIGIO)）</strong></p>
<p>首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。<br><img src="/img/信号驱动式IO模型.png" alt="信号驱动式IO模型"></p>
<p><strong>5.异步I/O （asynchronous I/O (the POSIX aio_functions)）</strong></p>
<p>告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核拷贝到用户自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是：信号驱动IO是由内核通知我们何时尅启动一个IO操作，异步IO模型则是由内核通知我们IO操作何时完成。<br><img src="/img/异步IO模型.png" alt="异步IO模型"></p>
<p><strong>五种IO模型的比较：</strong><br><img src="/img/五种IO模型的比较.png" alt="五种IO模型的比较">  </p>
<h4 id="三-select、poll、epoll概述">三.select、poll、epoll概述</h4><p><strong>1.select</strong></p>
<p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<ul>
<li>单个进程可监视的fd数量被限制，即能监听端口的大小有限。一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048。</li>
<li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍，这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</li>
<li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li>
</ul>
<p><strong>2.poll</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。<br>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</p>
<ul>
<li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                                                                                                                                      </li>
<li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
</ul>
<p><strong>3.epoll</strong></p>
<p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p>
<p><strong>epoll的优点：</strong></p>
<ul>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll。</li>
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li>
</ul>
<p><strong>注：</strong>本文所用的图片皆来自《unix网络编程卷1：套接字联网API》一书。  </p>
<h4 id="四-参考文献">四.参考文献</h4><ol>
<li>Unix网络编程卷1：套接字联网API（第3版）</li>
<li>Java IO: BIO, NIO, AIO <a href="http://halo9pan.info/2014/08/java-io/" target="_blank" rel="external">http://halo9pan.info/2014/08/java-io/</a> </li>
<li>socket阻塞与非阻塞，同步与异步 <a href="http://blog.csdn.net/hguisu/article/details/7453390" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/7453390</a></li>
<li>使用异步I/O大大提高应用程序的性能 <a href="http://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-async/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在研究nio和netty时，对它们的底层实现不是很了解，因此查阅了相关的资料，总结了在操作系统层面的IO通信模型。本文主要是基于unix环境来介绍，毕竟平常的服务器很少用windows的环境当服务器。要想深入的学习网络编程还得看看《unix网络编程》这本大名鼎鼎的书（包括卷]]>
    </summary>
    
      <category term="IO" scheme="http://wangtianzhi.cn/tags/IO/"/>
    
      <category term="网络" scheme="http://wangtianzhi.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="http://wangtianzhi.cn/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[quartz集群调度与源码剖析]]></title>
    <link href="http://wangtianzhi.cn/2016/01/03/quartz-source-analysis/"/>
    <id>http://wangtianzhi.cn/2016/01/03/quartz-source-analysis/</id>
    <published>2016-01-03T12:39:19.000Z</published>
    <updated>2016-01-03T13:05:57.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-quartz概述">一.quartz概述</h4><p>quartz是一个用JAVA实现的开源的任务调度框架。quartz可以用来创建简单或复杂的任务调度，它包括了许多企业级的功能，如支持JTA transactions和集群等。quartz是现在最流行的JAVA任务调度框架。</p>
<p><strong>quartz具有如下的特点</strong>：</p>
<ol>
<li>强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊的需求；</li>
<li>灵活的应用方式，例如支持任务和调度的多种组合方式，支持调度数据的多种存储方式；</li>
<li>分布式和集群能力，支持集群运行，具有负载均衡、故障恢复等功能，伸缩性高，高可用。</li>
</ol>
<p>此外，quartz是spring的默认调度框架，能够很容易的与spring集成。本文基于spring3.2.2和quartz2.2.1来讨论。注意 <strong>spring3.1以下的版本必须使用quartz1.x系列,3.1以上的版本才支持quartz 2.x</strong>，因为quartz1.x和quartz2.x有些地方不兼容。</p>
<p><strong>quartz调度核心元素</strong>：</p>
<ol>
<li>Scheduler:任务调度器，是实际执行任务调度的控制器。在spring中通过SchedulerFactoryBean封装起来。</li>
<li>Trigger：触发器，用于定义任务调度的时间规则，有SimpleTrigger,CronTrigger,DateIntervalTrigger和NthIncludedDayTrigger，其中CronTrigger用的比较多，本文主要介绍这种方式。CronTrigger在spring中封装在CronTriggerFactoryBean中。</li>
<li>Calendar:它是一些日历特定时间点的集合。一个trigger可以包含多个Calendar，以便排除或包含某些时间点。</li>
<li>JobDetail:用来描述Job实现类及其它相关的静态信息，如Job名字、关联监听器等信息。在spring中有JobDetailFactoryBean和 MethodInvokingJobDetailFactoryBean两种实现，如果任务调度只需要执行某个类的某个方法，就可以通过MethodInvokingJobDetailFactoryBean来调用。</li>
<li>Job：是一个接口，只有一个方法void execute(JobExecutionContext context),开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中。实现Job接口的任务，默认是无状态的，若要将Job设置成有状态的，在quartz中是给实现的Job添加@DisallowConcurrentExecution注解（以前是实现StatefulJob接口，现在已被Deprecated）,在与spring结合中可以在spring配置文件的job detail中配置concurrent参数。</li>
</ol>
<p><strong>quartz集群配置：</strong><br>quartz集群是通过数据库表来感知其他的应用的，各个节点之间并没有直接的通信。只有使用持久的JobStore才能完成Quartz集群。<br>数据库表：以前有12张表，现在只有11张表，现在没有存储listener相关的表，多了QRTZ_SIMPROP_TRIGGERS表：</p>
<table>
<thead>
<tr>
<th>Table name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>QRTZ_CALENDARS</td>
<td>存储Quartz的Calendar信息</td>
</tr>
<tr>
<td>QRTZ_CRON_TRIGGERS</td>
<td>存储CronTrigger，包括Cron表达式和时区信息</td>
</tr>
<tr>
<td>QRTZ_FIRED_TRIGGERS</td>
<td>存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息</td>
</tr>
<tr>
<td>QRTZ_PAUSED_TRIGGER_GRPS</td>
<td>存储已暂停的Trigger组的信息</td>
</tr>
<tr>
<td>QRTZ_SCHEDULER_STATE</td>
<td>存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td>
</tr>
<tr>
<td><strong>QRTZ_LOCKS</strong></td>
<td>存储程序的悲观锁的信息</td>
</tr>
<tr>
<td>QRTZ_JOB_DETAILS</td>
<td>存储每一个已配置的Job的详细信息</td>
</tr>
<tr>
<td>QRTZ_SIMPLE_TRIGGERS</td>
<td>存储简单的Trigger，包括重复次数、间隔、以及已触的次数</td>
</tr>
<tr>
<td>QRTZ_BLOG_TRIGGERS</td>
<td>Trigger作为Blob类型存储</td>
</tr>
<tr>
<td>QRTZ_TRIGGERS</td>
<td>存储已配置的Trigger的信息</td>
</tr>
<tr>
<td>QRTZ_SIMPROP_TRIGGERS</td>
<td></td>
</tr>
</tbody>
</table>
<p>QRTZ_LOCKS就是Quartz集群实现同步机制的行锁表,包括以下几个锁：CALENDAR_ACCESS 、JOB_ACCESS、MISFIRE_ACCESS 、STATE_ACCESS 、TRIGGER_ACCESS。</p>
<h4 id="二-quartz启动流程">二.quartz启动流程</h4><p>若quartz是配置在spring中，当服务器启动时，就会装载相关的bean。SchedulerFactoryBean实现了InitializingBean接口，因此在初始化bean的时候，会执行afterPropertiesSet方法，该方法将会调用SchedulerFactory(DirectSchedulerFactory 或者 StdSchedulerFactory，通常用StdSchedulerFactory)创建Scheduler。SchedulerFactory在创建quartzScheduler的过程中，将会读取配置参数，初始化各个组件，关键组件如下：</p>
<ol>
<li><p><strong>ThreadPool</strong>:一般是使用SimpleThreadPool,SimpleThreadPool创建了一定数量的WorkerThread实例来使得Job能够在线程中进行处理。WorkerThread是定义在SimpleThreadPool类中的内部类，它实质上就是一个线程。在SimpleThreadPool中有三个list：workers-存放池中所有的线程引用，availWorkers-存放所有空闲的线程，busyWorkers-存放所有工作中的线程；<br>线程池的配置参数如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPool</span><br><span class="line">org.quartz.threadPool.threadCount=<span class="number">3</span></span><br><span class="line">org.quartz.threadPool.threadPriority=<span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JobStore</strong>:分为存储在内存的RAMJobStore和存储在数据库的JobStoreSupport(包括JobStoreTX和JobStoreCMT两种实现，JobStoreCMT是依赖于容器来进行事务的管理，而JobStoreTX是自己管理事务），若要使用集群要使用JobStoreSupport的方式；</p>
</li>
<li><strong>QuartzSchedulerThread</strong>:用来进行任务调度的线程，在初始化的时候paused=true,halted=false,虽然线程开始运行了，但是paused=true，线程会一直等待，直到start方法将paused置为false；</li>
</ol>
<p>另外，SchedulerFactoryBean还实现了SmartLifeCycle接口，因此初始化完成后，会执行start()方法，该方法将主要会执行以下的几个动作：</p>
<ol>
<li>创建<strong>ClusterManager</strong>线程并启动线程:该线程用来进行集群故障检测和处理，将在下文详细讨论；</li>
<li>创建<strong>MisfireHandler</strong>线程并启动线程:该线程用来进行misfire任务的处理，将在下文详细讨论；</li>
<li>置QuartzSchedulerThread的paused=false，调度线程才真正开始调度；</li>
</ol>
<p>整个启动流程如下图：<br><img src="/img/quartz启动时序图.png" alt="quartz启动时序图"></p>
<h4 id="三-QuartzSchedulerThread线程">三.QuartzSchedulerThread线程</h4><p>线程的主要逻辑代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!halted.get()) &#123;</span><br><span class="line">  <span class="keyword">int</span> availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();</span><br><span class="line">  triggers = qsRsrcs.getJobStore().acquireNextTriggers(now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()),qsRsrcs.getBatchTimeWindow());</span><br><span class="line">  <span class="keyword">long</span> triggerTime = triggers.get(<span class="number">0</span>).getNextFireTime().getTime();</span><br><span class="line">  <span class="keyword">long</span> timeUntilTrigger = triggerTime - now;</span><br><span class="line">  <span class="keyword">while</span>(timeUntilTrigger &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    now = System.currentTimeMillis();</span><br><span class="line">    timeUntilTrigger = triggerTime - now;</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;TriggerFiredResult&gt; bndle = qsRsrcs.getJobStore().triggersFired(triggers);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; res.size();i++)&#123;</span><br><span class="line">    JobRunShell shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);</span><br><span class="line">    shell.initialize(qs);</span><br><span class="line">    qsRsrcs.getThreadPool().runInThread(shell);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先获取线程池中的可用线程数量（若没有可用的会阻塞，直到有可用的）；</li>
<li>获取30m内要执行的trigger(即acquireNextTriggers)：<br>获取trigger的锁，通过select …<strong>for update</strong>方式实现；获取30m内（可配置）要执行的triggers（<strong>需要保证集群节点的时间一致</strong>），若<strong>@ConcurrentExectionDisallowed</strong>且列表存在该条trigger则跳过，否则更新trigger状态为ACQUIRED(刚开始为WAITING)；插入firedTrigger表，状态为ACQUIRED;（注意：在RAMJobStore中，有个timeTriggers，排序方式是按触发时间nextFireTime排的；JobStoreSupport从数据库取出triggers时是按照nextFireTime排序）;</li>
<li>等待直到获取的trigger中最先执行的trigger在2ms内；</li>
<li>triggersFired：<br>1）更新firedTrigger的status=EXECUTING;<br>2）更新trigger下一次触发的时间；<br>3）更新trigger的状态：无状态的trigger-&gt;WAITING，有状态的trigger-&gt;BLOCKED，若nextFireTime==null -&gt;COMPLETE；<br>4） commit connection,释放锁；</li>
<li>针对每个要执行的trigger，创建JobRunShell，并放入线程池执行：<br>1）execute:执行job<br>2）获取TRIGGER_ACCESS锁<br>3）若是有状态的job：更新trigger状态：BLOCKED-&gt;WAITING,PAUSED_BLOCKED-&gt;BLOCKED<br>4）若@PersistJobDataAfterExecution，则updateJobData<br>5）删除firedTrigger<br>6）commit connection，释放锁</li>
</ol>
<p>线程执行流程如下图所示：<br><img src="/img/QuartzSchedulerThread.png" alt="QuartzSchedulerThread时序图"></p>
<p>任务调度执行过程中，trigger的状态变化如下图所示：<br><img src="/img/quartz集群trigger状态图.jpg" alt="该图来自参考文献5"></p>
<h4 id="四-misfireHandler线程">四.misfireHandler线程</h4><p>下面这些原因可能造成 misfired job:</p>
<ol>
<li>系统因为某些原因被重启。在系统关闭到重新启动之间的一段时间里，可能有些任务会被 misfire；</li>
<li>Trigger 被暂停（suspend）的一段时间里，有些任务可能会被 misfire；</li>
<li>线程池中所有线程都被占用，导致任务无法被触发执行，造成 misfire；</li>
<li>有状态任务在下次触发时间到达时，上次执行还没有结束；为了处理 misfired job，Quartz 中为 trigger 定义了处理策略，主要有下面两种：MISFIRE_INSTRUCTION_FIRE_ONCE_NOW：针对 misfired job 马上执行一次；MISFIRE_INSTRUCTION_DO_NOTHING：忽略 misfired job，等待下次触发；默认是MISFIRE_INSTRUCTION_SMART_POLICY，该策略在CronTrigger中=MISFIRE_INSTRUCTION_FIRE_ONCE_NOW线程默认1分钟执行一次；在一个事务中，默认一次最多recovery 20个；</li>
</ol>
<p>执行流程：</p>
<ol>
<li>若配置(默认为true，可配置)成获取锁前先检查是否有需要recovery的trigger，先获取misfireCount；</li>
<li>获取TRIGGER_ACCESS锁；</li>
<li>hasMisfiredTriggersInState：获取misfired的trigger，默认一个事务里只能最大20个misfired trigger（可配置），misfired判断依据：status=waiting,next_fire_time  &lt; current_time-misfirethreshold(可配置，默认1min)</li>
<li>notifyTriggerListenersMisfired</li>
<li>updateAfterMisfire:获取misfire策略(默认是MISFIRE_INSTRUCTION_SMART_POLICY，该策略在CronTrigger中=MISFIRE_INSTRUCTION_FIRE_ONCE_NOW)，根据策略更新nextFireTime；</li>
<li>将nextFireTime等更新到trigger表；</li>
<li>commit connection，释放锁8.如果还有更多的misfired，sleep短暂时间(为了集群负载均衡)，否则sleep misfirethreshold时间，后继续轮询；</li>
</ol>
<p>misfireHandler线程执行流程如下图所示：<br><img src="/img/MisfireHandler.png" alt="misfireHandler线程时序图"></p>
<h4 id="五-clusterManager线程">五.clusterManager线程</h4><p>初始化：<br>failedInstance=failed+self+firedTrigger表中的schedulerName在scheduler_state表中找不到的（孤儿）</p>
<p>线程执行：<br>每个服务器会定时(org.quartz.jobStore.<strong>clusterCheckinInterval</strong>这个时间)更新SCHEDULER_STATE表的LAST_CHECKIN_TIME，若这个字段远远超出了该更新的时间，则认为该服务器实例挂了；<br>注意：每个服务器实例有唯一的id，若配置为<strong>AUTO</strong>，则为hostname+current_time</p>
<p>线程执行的具体流程：</p>
<ol>
<li>检查是否有超时的实例failedInstances;</li>
<li>更新该服务器实例的LAST_CHECKIN_TIME；<br>若有超时的实例：</li>
<li>获取STATE_ACCESS锁；</li>
<li>获取超时的实例failedInstances;</li>
<li>获取TRIGGER_ACCESS锁；</li>
<li>clusterRecover:</li>
</ol>
<ul>
<li>针对每个failedInstances，通过instanceId获取每个实例的firedTriggers;</li>
<li>针对每个firedTrigger：<br>1) 更新trigger状态：<br>BLOCKED-&gt;WAITING<br>PAUSED_BLOCKED-&gt;PAUSED<br>ACQUIRED-&gt;WAITING<br>2) 若firedTrigger不是ACQUIRED状态（在执行状态）,且<strong>jobRequestRecovery</strong>=true:<br>创建一个SimpleTrigger，存储到trigger表，status=waiting,MISFIRE_INSTR=MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY.<br>3) 删除firedTrigger</li>
</ul>
<p>clusterManager线程执行时序图如下图所示：<br><img src="/img/ClusterManager.png" alt="clusterRecover线程时序图"></p>
<h4 id="六-_参考文献">六. 参考文献</h4><ol>
<li>Quartz Documentation <a href="http://quartz-scheduler.org/documentation" target="_blank" rel="external">http://quartz-scheduler.org/documentation</a></li>
<li>spring javadoc-api <a href="http://docs.spring.io/spring/docs/4.3.0.BUILD-SNAPSHOT/javadoc-api/" target="_blank" rel="external">http://docs.spring.io/spring/docs/4.3.0.BUILD-SNAPSHOT/javadoc-api/</a> </li>
<li>基于Quartz开发企业级任务调度应用 <a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/</a></li>
<li>quartz应用与集群原理分析 <a href="http://tech.meituan.com/mt-crm-quartz.html" target="_blank" rel="external">http://tech.meituan.com/mt-crm-quartz.html</a></li>
<li>quartz详解2：quartz由浅入深 <a href="http://ecmcug.itpub.net/11627468/viewspace-1763498/" target="_blank" rel="external">http://ecmcug.itpub.net/11627468/viewspace-1763498/</a></li>
<li>quartz详解4：quartz线程管理 <a href="http://blog.itpub.net/11627468/viewspace-1766967/" target="_blank" rel="external">http://blog.itpub.net/11627468/viewspace-1766967/</a></li>
<li>quartz学习笔记 <a href="http://www.cnblogs.com/yunxuange/archive/2012/08/28/2660141.html" target="_blank" rel="external">http://www.cnblogs.com/yunxuange/archive/2012/08/28/2660141.html</a></li>
<li>quartz集群调度机制调研及源码分析 <a href="http://demo.netfoucs.com/gklifg/article/details/27090179" target="_blank" rel="external">http://demo.netfoucs.com/gklifg/article/details/27090179</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="一-quartz概述">一.quartz概述</h4><p>quartz是一个用JAVA实现的开源的任务调度框架。quartz可以用来创建简单或复杂的任务调度，它包括了许多企业级的功能，如支持JTA transactions和集群等。quartz是现在最流行的JA]]>
    </summary>
    
      <category term="quartz" scheme="http://wangtianzhi.cn/tags/quartz/"/>
    
      <category term="源码分析" scheme="http://wangtianzhi.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="web开发" scheme="http://wangtianzhi.cn/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字符编码和中文乱码分析]]></title>
    <link href="http://wangtianzhi.cn/2015/12/13/character-and-chinese-error-code/"/>
    <id>http://wangtianzhi.cn/2015/12/13/character-and-chinese-error-code/</id>
    <published>2015-12-13T01:14:33.000Z</published>
    <updated>2015-12-13T13:55:22.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-_编码类型">一. 编码类型</h4><p><strong>1. ASCII</strong><br>ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）,是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。标准ASCII 码也叫基础ASCII码，使用7 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。其最高位(b7)用作奇偶校验位，后128个称为扩展ASCII码。许多基于x86的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8位用于确定附加的128个特殊符号字符、外来语字母和图形符号。<br><strong>2. ISO-8859-1</strong><br>ISO-8859-1编码是单字节编码，<strong>向下兼容ASCII</strong>，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。<br><strong>3. GB2312</strong><br>全称《信息交换用汉字编码字符集·基本集》，是双字节编码。GB 2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。<br><strong>4. GBK</strong><br>GBK全称《汉字内码扩展规范》，它的出现是为了扩展 GB2312，加入更多的汉字,包括繁体字。它的编码是和 GB2312 兼容的。<br>注意：gbk和gb2312的中文都是两个字节，英文（半角的）一个字节。<br><strong>5. GB18030</strong><br>是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。</p>
<p><strong>unicode</strong><br>虽然通过使用不同字符集，我们可以在一台机器上查阅不同语言的文档，但是我们仍然无法解决一个问题：在一份文档中显示所有字符。为了解决这个问题，我们需要一个全人类达成共识的巨大的字符集，这就是Unicode字符集。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。<br>虽然每个字符在Unicode字符集中都能找到唯一确定的编号（字符码，又称Unicode码），但是决定最终字节流的却是具体的字符编码,如utf-16或utf-8。例如同样是对Unicode字符“A”进行编码，UTF-8字符编码得到的字节流是0x41，而UTF-16（大端模式）得到的是0x00 0x41。<br><strong>6. UTF-16</strong><br>UTF-16 是 Unicode 字符在计算机中存取方法的一种具体编码。UTF-16支持Unicode全字符集的编解码，采用了变长编码，最少使用2个字节，如果要编码BMP以外的字符，则需要4个字节结对。当然，一般用BMP字符就够了，因此在网上很多都写utf-16是两个字节。<br><strong>7. UTF-8</strong><br>UTF-8应该是目前应用最广泛的一种Unicode编码方案。由于UCS-2/UTF-16对于ASCII字符使用两个字节进行编码，存储和处理效率相对低下，并且由于ASCII字符经过UTF-16编码后得到的两个字节，高字节始终是0x00，很多C语言的函数都将此字节视为字符串末尾从而导致无法正确解析文本。<br>对于ASCII字符的编码使用单字节，和ASCII编码一摸一样，这样所有原先使用ASCII编解码的文档就可以直接转到UTF-8编码了。对于其他字符，则使用2-4个字节来表示，其中，首字节前置1的数目代表正确解析所需要的字节数。</p>
<p>UTF-16 与 UTF-8 都是处理 Unicode 编码，它们的编码规则不太相同，相对来说 UTF-16 编码效率最高，字符到字节相互转换更简单，进行字符串操作也更好。它适合在本地磁盘和内存之间使用，可以进行字符和字节之间快速切换，如 Java 的内存编码就是采用 UTF-16 编码。但是它不适合在网络之间传输，因为网络传输容易损坏字节流，一旦字节流损坏将很难恢复，相比较而言 UTF-8 更适合网络传输，对 ASCII 字符采用单字节存储，另外单个字符损坏也不会影响后面其它字符，在编码效率上介于 GBK 和 UTF-16 之间，所以 UTF-8 在编码效率上和编码安全性上做了平衡，是理想的中文编码方式。</p>
<h4 id="二-_java中的编码">二. java中的编码</h4><p>在JVM内，从class文件加载的源码全部以UNICODE编码。在内存中倒腾String等数据是编码无关的，但是程序本身难免牵涉到外部文件的读写（如xml，properties文件等）、与数据库的交互、网络数据流读写等。这样就会造成很多非unicode编码的字符存在于JVM中，这也就是乱码出现的根本原因所在。</p>
<p>在使用IDE进行开发时，比如ECLIPSE,IDEA等，可以指定源文件（.java）的编码格式，此处的编码格式是指Java文件自身的编码。而xml、jsp、html等文件是能够自身描述文件编码的。xml可以通过encoding来指定编码方式，而html通过content-type方式来指定，如果打开这些文件，就会调用相应的编码方式来处理。但是经过javac命令编译后，生成的.class文件毫无疑问都是Unicode编码。<br>jvm在各个阶段都编码方式如下图所示：<br><img src="/img/jvm-encode.png" alt="jvm编码方式"><br>在存储java源文件时，是按照java文件的编码对文件进行编码，然后存储在磁盘中。当要对java源文件进行编译时，用源文件的编码对其进行解码，编译生成的class文件为unicode的编码方式。最终jvm加载class文件执行到jvm中，在jvm中的编码方式也是unicode。</p>
<p>在java中，主要用以下两个方法来对String进行编解码：</p>
<ul>
<li>getBytes(String charset)<br>将字符串按照指定的charset编码，返回其字节方式的表示。具体来说，实现的是从unicode—&gt;charset的转变。</li>
<li>new String(byte[] bytes,String charset)<br>将字节数组按照charset进行识别，最终转化为Unicode存储在JVM内，编码是从charset－&gt;unicode的转变。</li>
</ul>
<p>例如如下的例子：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> a=<span class="string">"中文"</span>;<span class="comment">//当然你可以以unicode的形式写成String a="\u4E2D\u6587"；</span></span><br><span class="line"><span class="built_in">byte</span>[] bs = a.getBytes(<span class="string">"gbk"</span>);</span><br><span class="line"><span class="keyword">String</span> b= <span class="keyword">new</span> <span class="keyword">String</span>(bs,<span class="string">"iso-8859-1"</span>);<span class="comment">//如果这里使用gbk编码进行解码的话，会自然的得到原来的a。</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出这个时候已经为乱码了，不过由于没有信息丢失，所以还是可以恢复成中文的。<br>恢复的过程为 <code>String c = new String(b.getBytes(&quot;iso-8859-1&quot;),&quot;gbk&quot;)</code>;<br>这种方式中间多了两次编解码，不推荐使用。</p>
<h4 id="三-_web编码">三. web编码</h4><p>用户从浏览器端发起一个 HTTP 请求，需要存在编码的地方是 URL、Cookie、Parameter。服务器端接受到 HTTP 请求后要解析 HTTP 协议，其中 URI、Cookie 和 POST 表单参数需要解码，服务器端可能还需要读取数据库中的数据，本地或网络中其它地方的文本文件，这些数据都可能存在编码问题，当 Servlet 处理完所有请求的数据后，需要将这些数据再编码通过 Socket 发送到用户请求的浏览器里，再经过浏览器解码成为文本。这些过程如下图所示：<br><img src="/img/url_encode_process.png" alt="该图来自参考文献3的文章"></p>
<p><strong>1. request编码</strong><br>URL的几个组成部分如下图所示：<br><img src="/img/url_construct.gif" alt="该图来自参考文献3的文章"></p>
<p>上图中以 Tomcat 作为 Servlet Engine 为例，它们分别对应到下面这些配置文件中：<br>Port 对应在 Tomcat 的 <code>&lt;Connector port=&quot;8080&quot;/&gt;</code> 中配置，而 Context Path 在 <code>&lt;Context path=&quot;/examples&quot;/&gt;</code> 中配置，Servlet Path 在 Web 应用的 web.xml 中的。注意这里是在浏览器里直接输入 URL 所以是通过 Get 方法请求的，如果是 POST 方法请求的话，QueryString 将通过表单方式提交到服务器端。<br><strong>a.URI</strong><br>一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号,这是因为网络标准<a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="external">RFC 1738</a>做了硬性规定:</p>
<blockquote>
<p>“只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!*’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。”</p>
</blockquote>
<p>这意味着，如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致”URL编码”成为了一个混乱的领域。由于不同浏览器可能采取不同的编码方式，因此url最好不要有中文字符；对于那些用js或模拟浏览器方式请求的（如httpclient），可以将url进行编码再提交，这样就能够得到控制。<br>在java中有<code>URLEncoder.encode(String s,String enc)／URLDecoder.decode(String s,String enc)</code>等方法，在javascript中有<code>escape/unescape</code>,<code>encodeURI/decodeURI</code>,<code>encodeURIComponent/decodeURIComponent</code>等方法。<br><strong>b.POST</strong><br>POST 表单参数传递方式是通过 HTTP 的 BODY 传递到服务端的。当我们在页面上点击 submit 按钮时浏览器首先将根据 ContentType 的 Charset 编码格式对表单填的参数进行编码然后提交到服务器端。</p>
<p><strong>2. request解码</strong><br>在服务器收到浏览器发来的请求后，需要对一些内容进行解码:<br><strong>a.URI</strong><br>对 URL 的 URI 部分进行解码的字符集是在 connector 的 <code>&lt;Connector URIEncoding=”UTF-8”/&gt;</code> 中定义的，如果没有定义，那么将以默认编码 ISO-8859-1 解析。所以如果有中文 URL 时最好把 URIEncoding 设置成 UTF-8 编码。<br><strong>b.GET</strong><br>GET方式的请求，QueryString 的解码字符集要么是 Header 中 ContentType 中定义的 Charset 要么就是默认的 ISO-8859-1，要使用 ContentType 中定义的编码就要设置 connector 的 <code>&lt;Connector URIEncoding=”UTF-8” useBodyEncodingForURI=”true”/&gt;</code>中的 useBodyEncodingForURI 设置为 true。这个配置项的名字有点让人产生混淆，它并不是对整个 URI 都采用 BodyEncoding 进行解码而仅仅是对 QueryString 使用 BodyEncoding 解码。设置了URIEncoding=“UTF-8”这样也可以。若useBodyEncodingForURI和URIEncoding同时设置了，useBodyEncodingForURI优先级高于URIEncoding。<br><strong>c.POST</strong><br>在服务器端同样也是用 ContentType 中字符集进行解码。所以通过 POST 表单提交的参数一般不会出现问题，而且这个字符集编码是我们自己设置的，可以通过 request.setCharacterEncoding(charset) 来设置。post方式的编码跟useBodyEncodingForURI和URIEncoding没关系。<br><strong>d.header</strong><br>Header中传递的其它参数如 Cookie、redirectPath。对 Header 中的项进行解码也是在调用 request.getHeader 是进行的，如果请求的 Header项没有解码则调用 MessageBytes 的 toString 方法，这个方法将从 byte 到 char 的转化使用的默认编码也是 ISO-8859-1，而我们也不能设置 Header 的其它解码格式，所以如果你设置 Header 中有非 ASCII 字符解码肯定会有乱码。</p>
<p><strong>3. response编码</strong><br>当用户请求的资源已经成功获取后，这些内容将通过 response 返回给客户端浏览器，这个过程先要经过编码再到浏览器进行解码。这个过程的编解码字符集可以通过 response.setCharacterEncoding 来设置，它将会覆盖 request.getCharacterEncoding 的值，并且通过 Header 的 Content-Type 返回客户端。服务器按照response.setCharacterEncoding—contentType—pageEncoding的优先顺序，对要发送的数据进行编码。</p>
<p><strong>4. response解码</strong><br>浏览器接受到返回的 socket 流时将通过 Content-Type 的 charset 来解码，如果返回的 HTTP Header 中 Content-Type 没有设置 charset，那么浏览器将根据 Html 的 <code>&lt;meta HTTP-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=GBK&quot; /&gt;</code> 中的 charset 来解码。如果也没有定义的话，那么浏览器将使用默认的编码来解码。</p>
<p><strong>注意：</strong></p>
<ol>
<li>GET 方式 HTTP 请求的 QueryString 与 POST 方式 HTTP 请求的表单参数都是作为 Parameters 保存，都是通过 request.getParameter 获取参数值。对它们的<strong>解码是在 request.getParameter 方法第一次被调用时进行的</strong>。所以<strong>request.setCharacterEncoding 应该设置在request.getParameter之前</strong>。</li>
<li><p>在java web开发中经常会添加filter来设置字符编码，如下所示：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在CharacterEncodingFilter里面，会执行<code>request.setCharacterEncoding(&#39;UTF-8&#39;)</code>的操作。该filter要设置在其他filter之前，否则可能不起作用，因为解码是在 request.getParameter 方法第一次被调用时进行的，如果其他filter通过request获取了参数，那么就解码了，再给request设置编码就不起作用了。</p>
</li>
<li>URIEncoding就是针对请求参数get的编码设置的，而filter的<code>request.setCharacterEncoding(&#39;UTF-8&#39;)</code>或者请求header中的content-type中的编码都是针对请求体的,不影响get方式的请求。</li>
<li>在jsp中<code>&lt;%@page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;</code>, pageEncoding和contentType都可以设置JSP源文件和响应正文中的字符集编码，但:<br>设置JSP源文件字符集时,优先级为pageEncoding&gt;contentType。如果都没有设置，默认ISO-8859-1。<br>设置响应输出的字符集时,优先级为contentType&gt;pageEncoding。如果都没有设置，默认ISO-8859-1。</li>
<li>jsp编译成servlet步骤：<br>第一步将jsp编译成.java：用pageEncoding编码来解码jsp文件，解码成unicode,转成servlet的java文件，用utf-8进行编码存储；<br>第二步用javac将java源码编译成.class文件：用utf-8解码java源码，转成unicode编码的class文件。</li>
</ol>
<h4 id="四-_参考文献">四. 参考文献</h4><ol>
<li><a href="http://www.imkevinyang.com/2010/06/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84.html" target="_blank" rel="external">关于字符编码，你所需要知道的（ASCII,Unicode,Utf-8,GB2312…）</a></li>
<li><a href="http://www.imkevinyang.com/2009/02/%E5%AD%97%E7%AC%A6%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%88ascii%EF%BC%8Cansi%EF%BC%8Cunicode%EF%BC%8Cutf-8%E5%8C%BA%E5%88%AB%EF%BC%89.html" target="_blank" rel="external">字符编解码的故事（ASCII，ANSI，Unicode，Utf-8区别）</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/" target="_blank" rel="external">深入分析 Java 中的中文编码问题</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="external">关于url编码</a></li>
<li><a href="http://lukejin.iteye.com/blog/586088" target="_blank" rel="external">深度剖析java的字符编码</a></li>
<li><a href="http://www.w3.org/International/questions/qa-byte-order-mark" target="_blank" rel="external">The byte-order mark(BOM) in HTML</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="一-_编码类型">一. 编码类型</h4><p><strong>1. ASCII</strong><br>ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）,是基于拉丁字母的一套]]>
    </summary>
    
      <category term="中文乱码" scheme="http://wangtianzhi.cn/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
      <category term="编码" scheme="http://wangtianzhi.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="web开发" scheme="http://wangtianzhi.cn/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[系统盘扩容及双系统启动项修复方法]]></title>
    <link href="http://wangtianzhi.cn/2015/10/08/partition-grub-rescue/"/>
    <id>http://wangtianzhi.cn/2015/10/08/partition-grub-rescue/</id>
    <published>2015-10-08T12:38:32.000Z</published>
    <updated>2015-10-08T15:11:52.000Z</updated>
    <content type="html"><![CDATA[<p>本人的笔记本电脑是win7+ubuntu14.04双系统，最近win7系统的系统盘快用完了，由于重装系统很麻烦，因此选择优化系统盘。由于平常都将软件装在非系统盘上，系统盘能够腾出空间的并不多，最终选择给系统盘扩容。由于是双系统，系统启动项是通过grub来引导的，在扩容后，系统无法进入开机启动项，在查找了很多资料后，终于恢复系统启动项。虽然以前也经历过这样的事情，但是到需要用到的时候，已经忘了怎么处理，且网上的很多解决方案并不完整，因此通过本文记录下这些问题的解决方案，方便日后再遇到时查阅。</p>
<p>首先，给系统盘扩容是采用<a href="http://www.partition-tool.com/download.htm" target="_blank" rel="external">EaseUS Partition Master</a>工具，免费版本的就足够了。打开软件，可以看到如下磁盘的分区信息：<br><img src="/img/partition master mainframe.png" alt=""><br>若要扩大C盘的大小，需要先从与C盘临近的盘释放一些空间出来，然后再将这些空间合并到C盘。具体步骤如下：</p>
<ol>
<li>选中与C盘临近的E盘（一般是D盘，不过本人的系统以前编号被改动过），右键选择’resize/move partition’，拖动滑块，调整磁盘大小。释放出空间后，再以同样的方法更改C盘的大小，将释放出来的空间增加到C盘：<br><img src="/img/partition resize.png" alt=""><br><img src="/img/partition resize2.png" height="400" width="400">   <img src="/img/partition resize3.png" height="400" width="400"></li>
<li>回到主界面单击Apply按钮，就可以开始分区。此过程需要重启系统，处理过程较慢。</li>
</ol>
<p>其次，由于改变了磁盘的分区，双系统的启动项会出现问题，在启动电脑时，会出现如下的问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error:unknown filesystem   </span><br><span class="line">grub rescue&gt;</span><br></pre></td></tr></table></figure></p>
<p>具体解决方式如下：</p>
<ol>
<li><p>查看分区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub rescue&gt;ls</span><br></pre></td></tr></table></figure>
</li>
<li><p>寻找Ubuntu所在分区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub rescue&gt;ls (hd0,msdos1)</span><br></pre></td></tr></table></figure>
<p>如果是unknown filesystem继续试下一个分区，直到找到Ubuntu所在分区，我的是在(hd0,msdos6)</p>
</li>
<li><p>修改启动分区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grub rescue&gt;set root=(hd0,msdos6)</span><br><span class="line">grub rescue&gt;set prefix=(hd0,msdos6)/boot/grub  (这里的格式可能会随grub的版本不同而不同)</span><br><span class="line">grub rescue&gt;insmod normal</span><br><span class="line">grub rescue&gt;set (用来查看配置信息)</span><br></pre></td></tr></table></figure>
<p>其中可以用set命令来查看配置信息。到这里如果一切正常，继续，否则说明Ubuntu所在分区不正确，先找好再继续。</p>
</li>
<li><p>进入启动菜单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub rescue&gt;normal</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入启动菜单后，立马按C进入命令行模式（如果直接进入系统，那么下次启动系统的时候启动项还是没有修复）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grub&gt;set root=(hd0,msdos6)</span><br><span class="line">grub&gt;set prefix=(hd0,msdos6)/boot/grub</span><br><span class="line">grub&gt;linux /vmlinuz  root=/dev/sda6（可按Tab键自动补全/vmlinuz）</span><br><span class="line">grub&gt;initrd /initrd.img (可按Tab键自动补全/initrd*)</span><br><span class="line">grub&gt;boot</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入Ubuntu修复grub:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo grub-install /dev/sda (重建grub到第一个硬盘,此处是sda而不是sda6，若报错可以加--force参数执行）</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启，完成。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本人的笔记本电脑是win7+ubuntu14.04双系统，最近win7系统的系统盘快用完了，由于重装系统很麻烦，因此选择优化系统盘。由于平常都将软件装在非系统盘上，系统盘能够腾出空间的并不多，最终选择给系统盘扩容。由于是双系统，系统启动项是通过grub来引导的，在扩容后，系]]>
    </summary>
    
      <category term="grub" scheme="http://wangtianzhi.cn/tags/grub/"/>
    
      <category term="分区" scheme="http://wangtianzhi.cn/tags/%E5%88%86%E5%8C%BA/"/>
    
      <category term="启动项" scheme="http://wangtianzhi.cn/tags/%E5%90%AF%E5%8A%A8%E9%A1%B9/"/>
    
      <category term="操作系统" scheme="http://wangtianzhi.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据库事务隔离级别]]></title>
    <link href="http://wangtianzhi.cn/2015/09/27/transaction/"/>
    <id>http://wangtianzhi.cn/2015/09/27/transaction/</id>
    <published>2015-09-27T06:40:49.000Z</published>
    <updated>2015-09-27T14:54:38.000Z</updated>
    <content type="html"><![CDATA[<p>事务是一系列操作组成的工作单元，该工作单元内的操作是不可分割的，即要么所有操作都做，要么所有操作都不做，这就是事务。</p>
<h3 id="ACID特性">ACID特性</h3><p>事务必需满足ACID（原子性、一致性、隔离性和持久性）特性，缺一不可：</p>
<ul>
<li><p><strong>原子性</strong>（Atomicity）：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做。如在银行中A给B转账：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update account set money= money - <span class="number">100</span> where name=<span class="string">'A'</span>;  </span><br><span class="line">update account set money= money + <span class="number">100</span> where name=<span class="string">'B'</span>;</span><br></pre></td></tr></table></figure>
<p>上述两条操作要么都执行，要么都不执行，否则会产生纠纷。在数据库管理系统（DBMS）中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。保障事务的原子性是数据库管理系统的责任，为此许多数据源采用日志机制。</p>
</li>
<li><strong>一致性</strong>（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数据还是处于正确的状态，即数据完整性约束没有被破坏；如银行转帐，不管有没有转账成功，应该保证事务结束后A+B的存款总额不变。保障一致性的方法可以从数据库层面和业务层面两方面入手。数据库层面的一致性是，在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,Check约束等)和触发器设置。业务一致性需要由开发人员进行保证。</li>
<li><strong>隔离性</strong>（Isolation）：并发事务执行之间无影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性。企业开发中，事务最复杂问题都是由事务隔离性引起的。一般情况下，完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。</li>
<li><strong>持久性</strong>（Durability）：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会因比如遇到系统故障或断电造成数据不一致或丢失。</li>
</ul>
<h3 id="事务常见问题">事务常见问题</h3><p>在实际项目开发中数据库操作一般都是并发执行的，即有多个事务并发执行，并发执行就可能遇到问题，目前常见的问题如下：</p>
<ul>
<li><strong>丢失更新</strong>：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，这是由于没有加锁造成的。</li>
<li><strong>脏读</strong>：脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。</li>
<li><strong>不可重复读</strong>：不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间更新了数据。</li>
<li><strong>幻读</strong>：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。</li>
</ul>
<h3 id="事务隔离级别">事务隔离级别</h3><p>为了解决这些并发问题，需要通过数据库隔离级别来解决，在标准SQL规范中定义了四种隔离级别：</p>
<ul>
<li><strong>未提交读</strong>（Read Uncommitted）：最低隔离级别，一个事务能读取到别的事务未提交的更新数据，很不安全，可能出现丢失更新、脏读、不可重复读、幻读；</li>
<li><strong>提交读</strong>（Read Committed）：一个事务能读取到别的事务提交的更新数据，不能看到未提交的更新数据，不可能出现丢失更新、脏读，但可能出现不可重复读、幻读;</li>
<li><strong>可重复读</strong>（Repeatable Read）：保证同一事务中先后执行的多次查询将返回同一结果，不受其他事务影响，不可能出现丢失更新、脏读、不可重复读，但可能出现幻读；</li>
<li><strong>序列化</strong>（Serializable）：最高隔离级别，不允许事务并发执行，而必须串行化执行，最安全，不可能出现更新、脏读、不可重复读、幻读。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">丢失更新</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"> 未提交读</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">  提交读</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"> 可重复读</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">  序列化</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p>隔离级别越高，数据库事务并发执行性能越差，能处理的操作越少。因此在实际项目开发中为了考虑并发性能一般使用提交读隔离级别，它能避免丢失更新和脏读，尽管不可重复读和幻读不能避免，但可以在可能出现的场合使用悲观锁或乐观锁来解决这些问题。sqlserver和oracle的默认隔离级别都是提交读，而mysql的innodb引擎的默认隔离级别为可重复读，且mysql通过一些机制来达到可重复读也能够避免幻读的情况。</p>
<p>本文只是介绍了事务的基本理论，后面等学完了相关的知识后，再专门介绍mysql的事务隔离级别的实现方法，以及spring锁的底层实现机制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>事务是一系列操作组成的工作单元，该工作单元内的操作是不可分割的，即要么所有操作都做，要么所有操作都不做，这就是事务。</p>
<h3 id="ACID特性">ACID特性</h3><p>事务必需满足ACID（原子性、一致性、隔离性和持久性）特性，缺一不可：</p>
<ul>]]>
    </summary>
    
      <category term="ACID" scheme="http://wangtianzhi.cn/tags/ACID/"/>
    
      <category term="事务" scheme="http://wangtianzhi.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="数据库" scheme="http://wangtianzhi.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用JAX-RS构建web服务]]></title>
    <link href="http://wangtianzhi.cn/2015/08/29/jax-rs-example/"/>
    <id>http://wangtianzhi.cn/2015/08/29/jax-rs-example/</id>
    <published>2015-08-29T15:16:23.000Z</published>
    <updated>2015-09-27T03:15:48.000Z</updated>
    <content type="html"><![CDATA[<p>前面介绍了REST和JAX-RS的基本概念，本文将以jersey为例，举例说明rest的实际使用方法。</p>
<p>Jersey 是 JAX-RS 的参考实现，Jersey1是JAX-RS的参考实现，Jersey2是JAX-RS2的参考实现。Jersey包含三个主要部分。</p>
<ul>
<li>核心服务器（Core Server）：通过提供 JSR 311 中标准化的注释和 API 标准化，您可以用直观的方式开发 RESTful Web 服务。</li>
<li>核心客户端（Core Client）：Jersey 客户端 API 帮助您与 REST 服务轻松通信。</li>
<li>集成（Integration）：Jersey 还提供可以轻松集成 Spring、Guice、Apache Abdera 的库。</li>
</ul>
<p><strong>基于jersey开发rest的流程如下：</strong></p>
<ol>
<li>引入jersey的jar包，<a href="https://jersey.java.net/" target="_blank" rel="external">https://jersey.java.net/</a></li>
<li><p>通过注解的方式定义rest service类，核心的部分如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   <span class="annotation">@Path</span>(<span class="string">"/library"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LibraryServiceImpl</span> <span class="keyword">implements</span> <span class="title">LibraryService</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@GET</span></span><br><span class="line">	<span class="annotation">@Path</span>(<span class="string">"books"</span>)</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBooks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"books"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="annotation">@GET</span></span><br><span class="line">	<span class="annotation">@Path</span>(<span class="string">"/book/&#123;isbn&#125;"</span>)</span><br><span class="line">	<span class="annotation">@Produces</span>(MediaType.APPLICATION_JSON)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Book <span class="title">getBook</span><span class="params">(@PathParam(<span class="string">"isbn"</span>)</span> ISBN id) </span>&#123;<span class="comment">//ISBN需要带一个String参数的构造方法</span></span><br><span class="line">		Book book = <span class="keyword">new</span> Book();</span><br><span class="line">		book.setId(id);</span><br><span class="line">		book.setName(<span class="string">"java book"</span>);</span><br><span class="line">		<span class="keyword">return</span> book;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="annotation">@POST</span></span><br><span class="line">	<span class="annotation">@Path</span>(<span class="string">"/book"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Response <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;<span class="comment">//实体参数</span></span><br><span class="line">		System.out.println(<span class="string">"name:"</span> + book.getName());</span><br><span class="line">		System.out.println(<span class="string">"id:"</span> + book.getId().getIsbn());</span><br><span class="line">		<span class="keyword">return</span> Response.ok().build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@DELETE</span></span><br><span class="line">	<span class="annotation">@Path</span>(<span class="string">"/book"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBook</span><span class="params">(@QueryParam(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"remove id:"</span> + id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述rest service中，可以通过GET方式访问project-path/library/books获取图书馆的所有书籍，以GET方式访问project-path/library/book/123获取ISBN的id为123的书的信息，其中请求头中的Accept类型需包含application/json类型的，url中的123将作为isbn的值，getBook(ISBN id)的参数值即为isbn的值。  </p>
<p>在上述实例中，各个资源的URI命名都是名词，且通过请求方式来进行区分请求的资源，如addBook(Book book)和remobeBook(String id)方法虽然请求的URI相同，但是一个是POST一个是DELETE方式，这样就能通过请求方法来简单的辨别出rest service的功能。此外，上述的Book实体需要在类上添加<code>@XmlRootElement</code>，ISBN作为参数需要带有一个String类型的构造函数或者一个包含接收单个字符串参数的valueOf静态方法。</p>
</li>
<li><p>添加web.xml配置  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">web-app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>JerseyFirstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.sun.jersey.spi.container.servlet.ServletContainer<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;init-param&gt;</span><br><span class="line">		设置REST资源所在的包(可选)</span><br><span class="line">		&lt;param-name&gt;com.sun.jersey.config.property.packages&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;com.tony.jersey.service&lt;/param-value&gt;</span><br><span class="line">	&lt;/init-param&gt; --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;com.tony.jersey.service.MyApplication&lt;/param-value&gt;</span><br><span class="line">	&lt;/init-param&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>JerseyFirstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加rest的servlet，url-pattern可以添加前缀，如果配置成<url-pattern>service/*</url-pattern>，那么上述的getBooks()方法的URL将变为…/service/library/books。还可以设置REST资源所在的包，这样只有这些包能够被当做rest service。<br>此外，还有其他的配置方法，如自定义Application类，用来注册service和provider，这样能够更灵活的控制service。通过这种方式实现的，需要在web.xml中添加<code>javax.ws.rs.Application</code>参数的配置，或者在自定义的Application类中添加<code>@ApplicationPath</code>注解。用注解方式来实现就可以不用web.xml配置了。</p>
</li>
<li>客户端调用rest service<br>jersey提供了客户端API，可以方便的调用service。当然，在JAX-RS2中，也提供了客户端的API。通过jersey的客户端API调用方式如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Client c = Client.create();</span><br><span class="line">WebResource r = c.resource(<span class="string">"http://localhost:8080/rest-jersey-demo/library..."</span>);</span><br><span class="line">ClientResponse response = r.get(ClientResponse.class);</span><br><span class="line"><span class="keyword">int</span> status = response.getStatus();</span><br><span class="line">String entity = response.getEntity(String.class);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当然，jersey还可以和spring集成，要和spring集成，只需要添加一个jersey-spring的包，并修改web.xml中配置的servlet类为<code>com.sun.jersey.spi.spring.container.servlet.SpringServlet</code>，很简单吧。</p>
<p>jersey2的包名和jersey1不一样，且jersey2提供了jax-rs2的实现，有异步调用、过滤器拦截器等功能，本文不详细介绍，下文将给出一个实例的地址，写的实例托管在bitbucket中，bitbucket也是国外的，不过在国内访问速度相对于github速度快些，且bitbucket还提供免费的私有仓库（无仓库个数限制，一个仓库最大容量1G，最大协作人数5人）。</p>
<p>最后，给出本实例的代码地址：</p>
<ol>
<li>jersey1的一个实例：<a href="https://bitbucket.org/tony404/rest-resteasy-demo" target="_blank" rel="external">https://bitbucket.org/tony404/rest-resteasy-demo</a></li>
<li>jersey2的一个实例：<a href="https://bitbucket.org/tony404/rest-jersey2-demo" target="_blank" rel="external">https://bitbucket.org/tony404/rest-jersey2-demo</a></li>
<li>jersey与spring的整合：<a href="https://bitbucket.org/tony404/rest-jersey-spring-demo" target="_blank" rel="external">https://bitbucket.org/tony404/rest-jersey-spring-demo</a></li>
<li>resteasy的一个简单实例：<a href="https://bitbucket.org/tony404/rest-resteasy-demo" target="_blank" rel="external">https://bitbucket.org/tony404/rest-resteasy-demo</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面介绍了REST和JAX-RS的基本概念，本文将以jersey为例，举例说明rest的实际使用方法。</p>
<p>Jersey 是 JAX-RS 的参考实现，Jersey1是JAX-RS的参考实现，Jersey2是JAX-RS2的参考实现。Jersey包含三个主要部分。]]>
    </summary>
    
      <category term="JAX-RS" scheme="http://wangtianzhi.cn/tags/JAX-RS/"/>
    
      <category term="jersey" scheme="http://wangtianzhi.cn/tags/jersey/"/>
    
      <category term="webservice" scheme="http://wangtianzhi.cn/tags/webservice/"/>
    
      <category term="webservice" scheme="http://wangtianzhi.cn/categories/webservice/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAX-RS初探]]></title>
    <link href="http://wangtianzhi.cn/2015/08/29/REST-JAX-RS/"/>
    <id>http://wangtianzhi.cn/2015/08/29/REST-JAX-RS/</id>
    <published>2015-08-29T13:07:25.000Z</published>
    <updated>2015-09-27T03:16:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JAX-RS概述">JAX-RS概述</h1><p>JAX-RS(Java API for RESTful Web Service，JSR-311)是Java提供用于开发RESTful Web服务基于注解(annotation)的API，在Java EE 6中发布，旨在定义一个统一的规范，使得Java程序员可以使用一套固定的接口来开发REST应用，避免了依赖第三方框架，同时JAX-RS使用POJO编程模型和基于注解的配置并集成JAXB，从而有效缩短了REST应用的开发周期，JSR-311开始于2007年2月，至今发布了两个最终版本1.0，1.1。Java EE7已经发布并且包含了最新的JAX-RS 2.0版本，它是Marek Potociar和Santiago Pericas-Geertsen领导的JSR-339实现。JAX-RS2.0主要的新特性包括：客户端API、异步、HATEOAS（超媒体）、注解、校验、过滤器和处理器（Handler）、内容协商。</p>
<p>JAX-RS定义的包结构如下，包含近五十多个接口，注解和抽象类:  </p>
<ul>
<li><strong>javax.ws.rs</strong>：包含用于创建RESTful服务资源的高层次（High-level）接口和注解；</li>
<li><strong>javax.ws.rs.core</strong>：包含用于创建RESTful服务资源的低层次（Low-level）接口和注解；</li>
<li><strong>javax.ws.rs.ext</strong>：包含用于扩展JAX-RS API支持类型的APIs；</li>
</ul>
<h1 id="JAX-RS主要接口/类介绍">JAX-RS主要接口/类介绍</h1><p>JAX-RS提供了一些标注将一个资源类，一个POJO Java类，封装为Web资源。标注包括：  </p>
<ul>
<li><strong>@Path</strong>，标注资源类或方法的相对路径。</li>
<li><strong>@GET，@PUT，@POST，@DELETE</strong>，标注方法使用的HTTP请求的类型；@GET获取资源，@PUT更新资源，具有幂等性（一次PUT操作和多次PUT操作的结果一样，都是资源被更新成新的内容），@POST添加资源，@DELETE删除资源；</li>
<li><strong>@Produces</strong>，标注返回的MIME媒体类型；</li>
<li><strong>@Consumes</strong>，标注可接受请求的MIME媒体类型；</li>
<li><strong>@PathParam，@QueryParam，@HeaderParam，@CookieParam，@MatrixParam，@FormParam</strong>分别标注方法的参数来自于HTTP请求的不同位置:<ul>
<li><strong>@PathParam</strong>来自于URL的路径；用于将 @Path 中的模板变量映射到方法参数，模板变量支持使用正则表达式，变量名与正则表达式之间用分号分隔</li>
<li><strong>@QueryParam</strong>来自于URL的查询参数；</li>
<li><strong>@HeaderParam</strong>来自于HTTP请求的头信息；</li>
<li><strong>@CookieParam</strong>来自于HTTP请求的Cookie；</li>
<li><strong>@MatrixParam</strong>来自于URI matrix参数值；</li>
<li><strong>@FormParam</strong>来自于form表单参数。</li>
</ul>
</li>
<li><strong>@Encoded</strong>，用于指明不自动URI解码参数值；</li>
<li><strong>@DefaultValue</strong>，用于为参数提供一个默认值；</li>
<li><strong>@Context</strong>，注入上下文对象；</li>
<li><strong>@HttpMethod</strong>，通过@HttpMethod可以自定义请求方法指示器；</li>
<li><strong>@Provider</strong>，用来声明provider类。</li>
</ul>
<h2 id="资源类&amp;资源方法">资源类&amp;资源方法</h2><p>Web 资源作为一个资源类来实现，对资源的请求由资源类的方法来处理。资源类或资源方法被打上了 Path 标注，Path 标注的值是一个相对的 URI 路径，用于对资源进行定位，路径中可以包含任意的正则表达式以匹配资源。和大多数 JAX-RS 标注一样，Path 标注是可继承的，子类或实现类可以继承超类或接口中的 Path 标注。<br>资源类是POJO，使用JAX-RS标注来实现相应的Web资源。资源类分为根资源类和子资源类，区别在于子资源类没有打在类上的Path 标注，根资源是由JAX-RS运行时实例化，子资源是由应用本身实例化。资源类的实例方法打上了 Path 标注，则为资源方法或子资源定位器，区别在于子资源定位器上没有任何 @GET、@POST、@PUT、@DELETE 或者自定义的 @HttpMethod。<br>如下例中，对widgets/offers的GET请求直接被WidgetsResource资源类的资源方法getDiscounted处理，而对widgets/xxx的GET请求则被WidgetResource资源类的getDetail方法处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Path</span>(“widgets”)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WidgetsResource</span> </span>&#123;  </span><br><span class="line"><span class="annotation">@GET</span>  </span><br><span class="line"><span class="annotation">@Path</span>(“offers”)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> WidgetList <span class="title">getDiscounted</span><span class="params">()</span> </span>&#123;…&#125;  </span><br><span class="line"><span class="annotation">@Path</span>(“&#123;id&#125;”)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> WidgetResource <span class="title">findWidget</span><span class="params">(@PathParam(“id”)</span> String id) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WidgetResource(id);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WidgetResource</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WidgetResouce</span><span class="params">(String id)</span> </span>&#123;…&#125;  </span><br><span class="line"><span class="annotation">@GET</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Widget <span class="title">getDetails</span><span class="params">()</span> </span>&#123;…&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参数标注">参数标注</h2><p>JAX-RS 中涉及的资源方法参数的标注包括：@PathParam、@MatrixParam、@QueryParam、@FormParam、@HeaderParam、@CookieParam、@DefaultValue 和 @Encoded。<br>未被标注的参数（称为实体参数）用于映射请求的实体部分；实体部分与Java类型之间的转换是由实体Provider提供。JAX-RS 规定资源方法中只允许有一个参数没有打上任何的参数标注。<br>只有public方法才能作为资源方法。</p>
<h2 id="参数和返回值类型">参数和返回值类型</h2><p><strong>资源方法合法的参数类型包括：</strong></p>
<ul>
<li>原生类型</li>
<li>构造函数接收单个字符串参数或者包含接收单个字符串参数的静态方法 valueOf 的任意类型；</li>
<li>List<t>，Set<t>，SortedSet<t>（T 为以上的 2 种类型）；</t></t></t></li>
<li>用于映射请求体的实体参数。</li>
</ul>
<p><strong>资源方法合法的返回值类型包括：</strong></p>
<ul>
<li>void：状态码 204 和空响应体</li>
<li>Response：Response 的 status 属性指定了状态码，entity 属性映射为响应体</li>
<li>GenericEntity：GenericEntity 的 entity 属性映射为响应体，entity 属性为空则状态码为 204，非空则状态码为 200</li>
<li>其它类型：返回的对象实例映射为响应体，实例为空则状态码为 204，非空则状态码为 200。  </li>
</ul>
<p>对于错误处理，资源方法可以抛出非受控异常 WebApplicationException 或者返回包含了适当的错误码集合的 Response 对象。</p>
<h2 id="Provider">Provider</h2><p>JAX-RS运行时通过应用提供的Provider类进行扩展；Provider是一个被@Provider标注并实现了一个或多个JAX-RS接口的类。实体Provider用于在请求/响应实体与Java类型之间进行映射，有两种：MessageBodyReader（请求实体映射到Java类型）和MessageBodyWriter（Java类型映射到响应实体）。默认一个JAX-RS应用中每个Provider只有一个实例。</p>
<p><strong>MessageBodyReader接口</strong>定义了JAX-RS运行时与那些提供了将实体映射到Java类型功能的组件之间的关系，一个提供该功能的类需要实现MessageBodyReader接口并被@Provider标注。</p>
<p><strong>JAX-RS实现处理请求实体到Java方法参数映射的逻辑步骤如下：</strong></p>
<ul>
<li>取得请求的媒体类型，如果请求中没有包含Content-Type请求头则使用application/octet-stream；</li>
<li>确定参数的Java类型，该类型能映射处理请求实体；</li>
<li>取得能支持请求媒体类型的MessageBodyReader Provider类集合；</li>
<li>遍历MessageBodyReader类集合，调用isReadable方法选择支持期望的Java类型的Provider类；</li>
<li>如果在第4步中确定了一个合适的MessageBodyReader类则调用readFrom方法将请求实体映射为期望的Java类型对象；</li>
<li>否则通过JavaBeans Activation Framework查找一个合适的数据处理器将请求实体映射为期望的Java类型；</li>
<li>否则生成WebApplicationException，包含一个不支持媒体类型的响应（415）和空实体；</li>
</ul>
<p><strong>MessageBodyWriter接口</strong>定义了JAX-RS运行时与那些提供了将Java类型映射到实体功能的组件之间的关系，一个提供该功能的类需要实现MessageBodyWriter接口并被@Provider标注。</p>
<p><strong>JAX-RS实现处理Java返回类型到响应实体的逻辑步骤如下：</strong></p>
<ul>
<li>取得将被映射为响应体的对象，如果返回类型是Response或其子类，则取entity属性的值，其他类型则取返回对象的值；</li>
<li>确定响应实体的媒体类型；</li>
<li>取得能支持响应媒体类型的MessageBodyWriter Provider类集合；</li>
<li>对类型的相近度对MessageBodyWriter进行排序；</li>
<li>遍历MessageBodyWriter类集合，调用isWriteable方法选择支持将Java对象映射为响应实体的Provider类；</li>
<li>如果在第4步中确定了一个合适的MessageBodyWriter类则调用writeTo方法将Java对象映射为响应实体；</li>
<li>否则通过JavaBeans Activation Framework查找一个合适的数据处理器将Java对象映射为响应实体；</li>
<li>否则生成WebApplicationException，包含一个服务器内部错误响应（500）和空包体；</li>
</ul>
<p>JAX-RS规范只是定义API，真正开发RESTful Web服务需要引入具体实现，具体实现由第三方提供，目前主要的实现有：</p>
<ul>
<li><strong>CXF</strong>——XFire和Celtix的合并（一个由IONA赞助的开源ESB，最初寄存在ObjectWeb上）。</li>
<li><strong>Jersey</strong>——Sun公司的JAX-RS参考实现。</li>
<li><strong>RESTEasy</strong>——JBoss的JAX-RS项目。</li>
<li><strong>Restlet</strong>——也许是最早的REST框架了，它JAX-RS之前就有了。</li>
</ul>
<h1 id="JAX-RS2-0新特性">JAX-RS2.0新特性</h1><p>在JavaEE7中包含了JAX-RS2.0,在JAX-RS2.0中包含了JAX-RS1的语法，同时新增了一些新的特性：</p>
<ol>
<li><p>客户端API<br>JAX-RS 1.0是一个严格的服务端API。有一些实现提供了不同程度的客户端支持。JAX-RS 2.0添加了“生成器（builder）”工具用于从客户端调用Web服务。以下为一个样例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get instance of Client</span></span><br><span class="line">Client client = ClientBuilder.newClient();</span><br><span class="line">String bal = client.target(<span class="string">"http://.../atm/&#123;cardId&#125;/balance"</span>)</span><br><span class="line">    .resolveTemplate(<span class="string">"cardId"</span>, <span class="string">"111122223333"</span>)</span><br><span class="line">    .queryParam(<span class="string">"pin"</span>, <span class="string">"9876"</span>) </span><br><span class="line">    .request(<span class="string">"text/plain"</span>).get(String.class);</span><br><span class="line">Invocation invocation1 = client.target(<span class="string">"http://.../atm/&#123;cardId&#125;/balance"</span>)…</span><br><span class="line">.request(“text/plain”).buildGet();</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步处理<br>在JAX-RS 1.0中，发起调用的客户端必须等待服务端的响应。2.0引入了异步的支持。这样的话就允许客户端发起一个RESTful的请求，并得到一个Future或an InvocationCallback，当响应完成的时候会获得通知。</p>
</li>
<li>HATEOAS（超媒体）<br>HATEOAS（Hypermedia as the Engine of Application State，超媒体作为应用程序状态引擎）需要RESTful的生产者和消费者在每次调用时返回一组达成共识的链接，它用于导航到下一个步骤。如果你将REST视为Web页面的应用版本，那么HATEOAS可以视为Web页面中的链接。<br>JAX-RS 2.0提供了Link和Target类，它们用于服务器端在响应中引入超链接并在客户端对其进行响应。</li>
<li>过滤器和处理器<br>Filter API允许将servlet的过滤器放到一个链中，遵循责任链模式。如果要引入一些正交的关注点，如日志，那么它会很有用。任何的过滤器都可以继续或终止这个链，这是通过分别调用FilterAction.NEXT和FilterAction.STOP做到的。</li>
<li><p>内容协商<br>更为丰富的参数注解@Accepts和@Produces能够让你优先安排请求/响应的格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Path(<span class="string">"widgets2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WidgetsResource2</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@GET</span></span><br><span class="line">    <span class="annotation">@Produces</span>(<span class="string">"text/plain; qs=0.5"</span>, <span class="string">"text/html; qs=0.75"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Widgets <span class="title">getWidget</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端发起下面的请求</span></span><br><span class="line">GET http:<span class="comment">//.../widgets2</span></span><br><span class="line">Accept: text<span class="comment">/*; q=1</span></span><br></pre></td></tr></table></figure>
<p>针对上述的请求，因为”text/plain”和”text/html”都匹配，但是”text/html”的因子比较高，因此会返回”text/html”类型的。</p>
</li>
<li>许多微小的 API 改进和扩展<br>如Bean 验证、请求 / 响应、URI 生成器、字符串转换器等等。</li>
<li>DI 集成、Java EE 安全性、MVC、延迟的高级客户端API</li>
</ol>
<p>下一篇将以jersey为例，举例说明JAX-RS的具体使用方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="JAX-RS概述">JAX-RS概述</h1><p>JAX-RS(Java API for RESTful Web Service，JSR-311)是Java提供用于开发RESTful Web服务基于注解(annotation)的API，在Java EE 6中发布]]>
    </summary>
    
      <category term="JAX-RS" scheme="http://wangtianzhi.cn/tags/JAX-RS/"/>
    
      <category term="REST" scheme="http://wangtianzhi.cn/tags/REST/"/>
    
      <category term="webservice" scheme="http://wangtianzhi.cn/tags/webservice/"/>
    
      <category term="webservice" scheme="http://wangtianzhi.cn/categories/webservice/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[webservice之REST]]></title>
    <link href="http://wangtianzhi.cn/2015/08/29/webservice-rest/"/>
    <id>http://wangtianzhi.cn/2015/08/29/webservice-rest/</id>
    <published>2015-08-29T08:59:11.000Z</published>
    <updated>2015-09-27T03:16:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>REST 是英文 Representational State Transfer 的缩写，有中文翻译为“具象状态传输”。REST 这个术语是由 Roy Fielding 在他的博士论文 《 Architectural Styles and the Design of Network-based Software Architectures 》中提出的。REST 并非标准，而是一种开发 Web 应用的架构风格，可以将其理解为一种设计模式。REST 基于 HTTP，URI，以及 XML 这些现有的广泛流行的协议和标准，伴随着 REST，HTTP 协议得到了更加正确的使用。</p>
<p>相较于基于 SOAP 和 WSDL 的 Web 服务，REST 模式提供了更为简洁的实现方案。目前，越来越多的 Web 服务开始采用 REST 风格设计和实现，真实世界中比较著名的 REST 服务包括：Google AJAX 搜索 API、Amazon Simple Storage Service (Amazon S3)等。REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 </p>
<h2 id="基于_REST_的_Web_服务遵循一些基本的设计原则：">基于 REST 的 Web 服务遵循一些基本的设计原则：</h2><ul>
<li>网络上的所有事物都被抽象为资源；</li>
<li>系统中的每一个对象或是资源都可以通过一个唯一的 URI 来进行寻址，URI 的结构应该简单、可预测且易于理解，比如定义目录结构式的 URI；</li>
<li>以遵循 RFC-2616 所定义的协议的方式显式地使用 HTTP 方法，建立创建、检索、更新和删除（CRUD：Create, Retrieve, Update and Delete）操作与 HTTP 方法之间的一对一映射：  <ul>
<li>若要在服务器上创建资源，应该使用 POST 方法；  </li>
<li>若要检索某个资源，应该使用 GET 方法；</li>
<li>若要更改资源状态或对其进行更新，应该使用 PUT 方法；</li>
<li>若要删除某个资源，应该使用 DELETE 方法。</li>
</ul>
</li>
<li>URI 所访问的每个资源都可以使用不同的形式加以表示（比如 XML 或者 JSON），具体的表现形式取决于访问资源的客户端，客户端与服务提供者使用一种内容协商的机制（请求头与 MIME 类型）来选择合适的数据格式，最小化彼此之间的数据耦合。</li>
<li>无状态通讯；服务器端不能保持除了单次请求之外的，任何与其通信的客户端的通信状态。无状态约束使服务器的变化对客户端是不可见的，因为在两次连续的请求中，客户端并不依赖于同一台服务器。</li>
</ul>
<h2 id="REST架构与SOAP_WebService比较：">REST架构与SOAP WebService比较：</h2><ul>
<li>成熟度<br>SOAP目前成熟，不同平台，开发语言之间通过SOAP来交互的web service都能够较好的互通。REST相对不太成熟，由于没有类似于SOAP的权威性协议作为规范，REST实现的各种服务风格不一，通用性不强。</li>
<li>效率和易用性<br>SOAP使用门槛高（学习成本高，开发难度大），由于SOAP由于各种需求不断扩充其本身协议的内容，在大并发下性能有所下降。REST 目前大量的Web 2.0网站使用，高效以及简洁易用，例如很多大型网站开放的REST风格的API都会有多种返回形式，除了传统的xml作为数据承载，还有（JSON,RSS,ATOM）等形式，这对很多网站前端开发人员来说就能够很好的mashup各种资源信息。这种高效一方面源于其面向资源接口设计以及操作抽象简化了开发者的不良设计，同时也最大限度的利用了Http最初的应用协议设计理念。REST 是一种轻量级的Web Service架构风格，其实现和操作明显比SOAP和XML-RPC更为简洁，可以完全通过HTTP协议实现，还可以利用缓存Cache来提高响应速度，性能、效率和易用性上都优于SOAP协议。同时由于通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性。</li>
<li>安全性<br>SOAP在安全方面是通过使用XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的，当前已经得到了各个厂商的支持，.net ，php ，java 都已经对其有了很好的支持。REST没有任何规范对于安全方面作说明。因此在考虑安全性上，SOAP要高于REST。</li>
</ul>
<p>总的来说，REST对于资源型服务接口来说很合适，同时特别适合对于效率要求很高，但是对于安全要求不高的场景。而SOAP的成熟性可以给需要提供给多开发语言的，对于安全性要求较高的接口设计带来便利。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>REST 是英文 Representational State Transfer 的缩写，有中文翻译为“具象状态传输”。REST 这个术语是由 Roy Fielding 在他的博士论文 《 Architectural Styles an]]>
    </summary>
    
      <category term="REST" scheme="http://wangtianzhi.cn/tags/REST/"/>
    
      <category term="webservice" scheme="http://wangtianzhi.cn/tags/webservice/"/>
    
      <category term="webservice" scheme="http://wangtianzhi.cn/categories/webservice/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树状数组]]></title>
    <link href="http://wangtianzhi.cn/2014/02/19/binary-indexed-tree/"/>
    <id>http://wangtianzhi.cn/2014/02/19/binary-indexed-tree/</id>
    <published>2014-02-19T07:54:53.000Z</published>
    <updated>2015-08-29T12:06:24.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述"><strong>1. 概述</strong></h3><p>树状数组(BIT ,binary indexed tree)是一种查询和修改的时间复杂度都为log(n)的数据结构。传统的数组连续元素求和的时间复杂度为O(n),而树状数组通过将线性结构转换成伪树状结构，将复杂度降为log(n)。</p>
<h3 id="2-_树状数组的结构"><strong>2. 树状数组的结构</strong></h3><p>给定数组A,我们定义数组C，满足C[i]=A[i-2^k+1]+…+A[i],其中k为i转成二进制后末尾的0的个数，i从1开始计算，则我们称C为树状数组。其中2^k = i&amp;(i^(i-1)),即i与i-1做异或运算再与i做与运算。</p>
<a id="more"></a>
<p>数组C的具体含义如下图所示：</p>
<p><img src="/img/binary indexed tree.jpg" alt=""></p>
<p>C[1]=A[1];<br>C[2]=A[1]+A[2];<br>C[3]=A[3];<br>C[4]=A[1]+A[2]+A[3]+A[4];<br>…<br>C[7]=A[7];<br>C[8]=A[1]+…+A[8];<br>分析上面的几组式子可知，当i为奇数时，C[i]=A[i] ；当i为偶数时，就要看i的因子中最多有二的多少次幂。例如，6的因子中有2的一次幂，等于2，所以C[6]=A[5]+A[6]（由六向前数两个数的和），4的因子中有2的两次幂，等于4，所以C[4]=A[1]+A[2]+A[3]+A[4]（由四向前数四个数的和） 。当我们修改A[i]的值时，只需要沿着C[i]往跟结点上溯，修改这条路上的所有结点即可，这种操作最坏情况下的时间复杂度为树的高度即log(n)，比线性结构的数组的复杂度O(n)快。</p>
<h3 id="3-_代码实现"><strong>3. 代码实现</strong></h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求2^k</span></span><br><span class="line"><span class="keyword">int</span> lowbit(<span class="keyword">int</span> t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> t &amp; ( t ^ ( t - <span class="number">1</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求前n项和</span></span><br><span class="line"><span class="comment">//求出来 2^k 之后，数组C的值就都出来了</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">sum</span>(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	 <span class="keyword">sum</span> += C[n];</span><br><span class="line">	 n -= lowbit(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//给某个节点pos加上num</span></span><br><span class="line"><span class="keyword">void</span> plus(<span class="keyword">int</span> pos, <span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">while</span>(pos &lt;= n)</span><br><span class="line">  &#123;</span><br><span class="line">	 C[pos] += num;</span><br><span class="line">	 pos += lowbit(pos);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-_参考资料"><strong>4. 参考资料</strong></h3><p>[1]. <a href="http://hawstein.com/posts/binary-indexed-trees.html" target="_blank" rel="external">http://hawstein.com/posts/binary-indexed-trees.html</a><br>[2]. <a href="http://dongxicheng.org/structure/binary_indexed_tree/" target="_blank" rel="external">http://dongxicheng.org/structure/binary_indexed_tree/</a><br>[3]. <a href="http://www.cnblogs.com/zhangshu/archive/2011/08/16/2141396.html" target="_blank" rel="external">http://www.cnblogs.com/zhangshu/archive/2011/08/16/2141396.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述"><strong>1. 概述</strong></h3><p>树状数组(BIT ,binary indexed tree)是一种查询和修改的时间复杂度都为log(n)的数据结构。传统的数组连续元素求和的时间复杂度为O(n),而树状数组通过将线性结构转换成伪树状结构，将复杂度降为log(n)。</p>
<h3 id="2-_树状数组的结构"><strong>2. 树状数组的结构</strong></h3><p>给定数组A,我们定义数组C，满足C[i]=A[i-2^k+1]+…+A[i],其中k为i转成二进制后末尾的0的个数，i从1开始计算，则我们称C为树状数组。其中2^k = i&amp;(i^(i-1)),即i与i-1做异或运算再与i做与运算。</p>]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://wangtianzhi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://wangtianzhi.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://wangtianzhi.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <link href="http://wangtianzhi.cn/2014/02/03/the-strategy-pattern/"/>
    <id>http://wangtianzhi.cn/2014/02/03/the-strategy-pattern/</id>
    <published>2014-02-03T01:51:07.000Z</published>
    <updated>2015-08-29T10:17:12.000Z</updated>
    <content type="html"><![CDATA[<p>寒假带着《head first设计模式》这本厚厚的书准备系统的学习一下设计模式。不同于以往枯燥的讲解知识点，Head first以幽默通俗易懂的形式将知识呈现在读者面前。以前也看过设计模式的其它一些书籍，虽然讲解全面，却不好理解，且一味的讲解知识点容易让人犯困。看了《head first 设计模式》前面一部分，其特有的讲解模式让我印象深刻，容易理解。本文还将OO的设计原则贯穿于设计模式的讲解中，让人更深刻的把握OO设计原则和设计模式的精髓。</p>
<p>书上观察者模式的定义如下：</p>
<blockquote>
<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
</blockquote>
<a id="more"></a>
<p><img src="/img/the strategy pattern.png" alt=""><br>本文引用书上的例子。有各种各样的鸭子，不同的鸭子行为可能不一样，叫声不一样、飞行行为不一样、外观不一样等等。<br>鸭子的主体：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">	FlyBehavior flyBehavior;</span><br><span class="line">	QuackBehavior quackBehavior;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span> <span class="params">(FlyBehavior fb)</span> </span>&#123;</span><br><span class="line">		flyBehavior = fb;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior qb)</span> </span>&#123;</span><br><span class="line">		quackBehavior = qb;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		flyBehavior.fly();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		quackBehavior.quack();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"All ducks float, even decoys!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Duck中包含两个实例变量“flyBehavior”与“quackBehavior”，声明为接口类型，每个鸭子对象都会动态的设置这些变量以在运行时引用正确的行为类型（如:FlyWithWings,Quack等）。<br>鸭子行为的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>鸭子行为的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"I'm flying!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Quack"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体鸭子的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedHeadDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RedHeadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		flyBehavior = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">		quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"I'm a real Red Headed duck"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniDuckSimulator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		MallardDuck	mallard = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">		RubberDuck	rubberDuckie = <span class="keyword">new</span> RubberDuck();</span><br><span class="line">		DecoyDuck	decoy = <span class="keyword">new</span> DecoyDuck();</span><br><span class="line"> </span><br><span class="line">		ModelDuck	model = <span class="keyword">new</span> ModelDuck();</span><br><span class="line"></span><br><span class="line">		mallard.performQuack();</span><br><span class="line">		rubberDuckie.performQuack();</span><br><span class="line">		decoy.performQuack();</span><br><span class="line">   </span><br><span class="line">		model.performFly();	</span><br><span class="line">		model.setFlyBehavior(<span class="keyword">new</span> FlyRocketPowered());</span><br><span class="line">		model.performFly();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>寒假带着《head first设计模式》这本厚厚的书准备系统的学习一下设计模式。不同于以往枯燥的讲解知识点，Head first以幽默通俗易懂的形式将知识呈现在读者面前。以前也看过设计模式的其它一些书籍，虽然讲解全面，却不好理解，且一味的讲解知识点容易让人犯困。看了《head first 设计模式》前面一部分，其特有的讲解模式让我印象深刻，容易理解。本文还将OO的设计原则贯穿于设计模式的讲解中，让人更深刻的把握OO设计原则和设计模式的精髓。</p>
<p>书上观察者模式的定义如下：</p>
<blockquote>
<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="strategy" scheme="http://wangtianzhi.cn/tags/strategy/"/>
    
      <category term="策略模式" scheme="http://wangtianzhi.cn/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wangtianzhi.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wangtianzhi.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开始使用个人博客]]></title>
    <link href="http://wangtianzhi.cn/2014/01/27/first-article/"/>
    <id>http://wangtianzhi.cn/2014/01/27/first-article/</id>
    <published>2014-01-27T06:17:10.000Z</published>
    <updated>2016-02-05T12:08:13.000Z</updated>
    <content type="html"><![CDATA[<p>前两天看到<a href="http://xidianpanpei.github.io/" target="_blank" rel="external">培哥</a>将个人博客改为<a href="https://github.com/hexojs/hexo" target="_blank" rel="external">hexo</a>，看了界面挺简洁的，配置简单，而且hexo用的是node.js，速度较快，遂决定也搭建一个自己的博客。其实很早以前就打算搭建自己的博客了，当初是打算用wordpress搭建自己的博客，后来发现比较麻烦，也没有时间去折腾，把这事耽了很久。恰好寒假在家可以上网，而且相对比较闲，就折腾了一把。</p>
<p>以前用的是iteye的博客，后来想迁移到博客园，不过在将文章导到博客园时没有成功，就一直用的iteye。原来博客上的很多文章都是转载的（转载的在文章里都有注明出处），也经常没有更新，一方面是由于最近比较忙，都忘了有博客的存在了；另一方面是没有养成写博客的习惯，总觉得麻烦。<br><a id="more"></a></p>
<p>当然，我深知写博客的好处，特别是作为一名程序猿，保持写博客的习惯是很有必要的。开通此博客，希望能够多写一些自己原创的文章，记录学习过程中的点点滴滴。</p>
<p>在搭建此博客的过程中也遇到了种种问题，或是请教<a href="http://xidianpanpei.github.io/" target="_blank" rel="external">培哥</a>、<a href="http://littlebean.github.io/" target="_blank" rel="external">XXL</a>，或是找度娘、google。当然，最主要参考的内容是 <a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">zipperary</a>的博客。在搭建过程中遇到的较大的问题mark如下：</p>
<ol>
<li>hexo deploy不成功时，要先删除.deploy。</li>
<li>hexo2.4.5默认主题为landscape，本博客改为light，从git clone到themes下，官方说要update，update后就不能用了，所以不要update。</li>
</ol>
<p>仅以此文mark自己的新博客。</p>
<p>更新：</p>
<p>博客主题改为jacman。</p>
<p>2015.10.11更新：</p>
<p>原先的博客代码是托管在github上的，最近发现github拦截百度的爬虫，因此百度就无法将博客加入索引。现将博客迁到gitcafe上，gitcafe是国内的平台，速度较快。</p>
<p>再次更新：<br>gitcafe不稳定，再托管到github上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前两天看到<a href="http://xidianpanpei.github.io/">培哥</a>将个人博客改为<a href="https://github.com/hexojs/hexo">hexo</a>，看了界面挺简洁的，配置简单，而且hexo用的是node.js，速度较快，遂决定也搭建一个自己的博客。其实很早以前就打算搭建自己的博客了，当初是打算用wordpress搭建自己的博客，后来发现比较麻烦，也没有时间去折腾，把这事耽了很久。恰好寒假在家可以上网，而且相对比较闲，就折腾了一把。</p>
<p>以前用的是iteye的博客，后来想迁移到博客园，不过在将文章导到博客园时没有成功，就一直用的iteye。原来博客上的很多文章都是转载的（转载的在文章里都有注明出处），也经常没有更新，一方面是由于最近比较忙，都忘了有博客的存在了；另一方面是没有养成写博客的习惯，总觉得麻烦。<br>]]>
    
    </summary>
    
      <category term="hexo" scheme="http://wangtianzhi.cn/tags/hexo/"/>
    
      <category term="light" scheme="http://wangtianzhi.cn/tags/light/"/>
    
      <category term="杂文" scheme="http://wangtianzhi.cn/categories/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
</feed>